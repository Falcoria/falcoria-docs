{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"What is Falcoria","text":"<p>Falcoria is a distributed scanning and coordination platform built for penetration testers and red teams. It automates host discovery, port scanning, and result consolidation across multiple systems \u2014 giving you real-time visibility into your perimeter and removing the need for fragmented tools or outdated results.</p>"},{"location":"#why-falcoria","title":"Why Falcoria","text":"<p>Falcoria is not just a scanner \u2014 it's a real-time perimeter awareness system designed to help you stay in control of your external attack surface.</p>"},{"location":"#key-benefits","title":"Key Benefits","text":"<p>\u2705 Lightning-fast distributed scanning \u2014 Split tasks across multiple workers to drastically reduce scan time.  </p> <p>\u2705 Intelligent updates and clean data handling \u2014 Filters duplicates, tracks meaningful changes, and keeps your results organized. Four import modes give you complete control over how data is added, updated, or replaced.  </p> <p>\u2705 Centralized visibility and perimeter control \u2014 Scan results and configurations stay in one place. Full CLI management to launch scans, track status, and review results. Built for teams that need perimeter control, not guesswork.</p>"},{"location":"#who-its-for","title":"Who It's For","text":"<p>Falcoria is built for:</p> <ul> <li>Penetration testers managing complex or dynamic scopes  </li> <li>Red teams running distributed reconnaissance  </li> <li>Security engineers automating scan workflows across environments  </li> </ul>"},{"location":"#what-falcoria-provides","title":"What Falcoria Provides","text":"<p>Speeds up infrastructure scans by splitting tasks across distributed workers. Scans complete in minutes or hours \u2014 not days \u2014 with no false positives or missing data.  Learn how distributed scanning works \u203a</p> <p>Automates scan data management \u2014 merging reports, removing duplicates, and keeping results centrally organized and searchable. No more manual cleanup, scattered files, or repeat scans just to find what you\u2019ve already discovered. Learn how deduplication works \u203a</p> <p>Delivers real-time access to scan results for every team member \u2014 with native support for JSON, XML, and API integrations. No waiting for reports, no manual exports, no compatibility issues between tools or teammates. See how teams access and collaborate on results \u203a</p> <p>Scales with your needs \u2014 start with a one-liner, or dive deep using config files and CLI options. Share scan presets across teams for consistency, or fine-tune settings per project for precise control. See how to configure and share scan presets \u203a</p>"},{"location":"#get-started","title":"Get Started","text":"<p>Want to see how Falcoria works in practice? Start here: Common Workflow \u2014 Step-by-Step Example</p> <ul> <li>Installation Guide</li> <li>Import Modes</li> <li>Architecture Overview</li> </ul>"},{"location":"#watch-falcoria-in-action","title":"Watch Falcoria in Action","text":"Your browser does not support the video tag. [Download Video](videos/falcoria_common_workflow.mp4)"},{"location":"architecture/","title":"Architecture Overview","text":"<p>Falcoria is a modular scanning system built for automation and scale. It coordinates multiple machines to scan large environments faster \u2014 while keeping results accurate, organized, and easy to access.</p>"},{"location":"architecture/#core-components","title":"Core Components","text":"<ul> <li> <p>CLI (<code>falcli</code>)   Command-line interface for launching scans, importing data, and retrieving results via API.</p> </li> <li> <p>Tasker (API)   Orchestrates scan requests. It validates input, deduplicates targets, associates scans with projects, and queues tasks for execution.</p> </li> <li> <p>Worker   Executes scan tasks using Nmap. Designed for parallel execution and horizontal scaling.</p> </li> <li> <p>ScanLedger (API)   Backend API for storing and retrieving scan results. Also supports importing external scan data and accessing metadata.</p> </li> <li> <p>Redis   Tracks scan state during execution and enforces deduplication during task creation.</p> </li> <li> <p>RabbitMQ   Message broker that distributes scan tasks from Tasker to Worker nodes.</p> </li> </ul>"},{"location":"architecture/#system-diagram","title":"System Diagram","text":""},{"location":"architecture/#scan-workflow","title":"Scan Workflow","text":"<ol> <li>The user runs <code>falcli</code> with a list of targets and optional scan configuration.</li> <li><code>falcli</code> sends the request to Tasker via API.</li> <li>Tasker validates the request, links it to a project, applies deduplication, and prepares scan tasks.</li> <li>Tasks are pushed to RabbitMQ.</li> <li>Workers receive tasks and execute scans using Nmap.</li> <li>Scan results are sent to ScanLedger.</li> <li>Results can be retrieved via <code>falcli</code>.</li> </ol>"},{"location":"architecture/#scalability","title":"Scalability","text":"<ul> <li>Workers can be added or removed dynamically.</li> <li>Each Worker supports parallel execution.</li> <li>The architecture has no fixed upper limit on Worker count.</li> </ul>"},{"location":"architecture/#extensibility","title":"Extensibility","text":"<p>Falcoria is built for modularity and scan chaining. Planned or supported extensions include:</p> <ul> <li>Tool chaining (e.g., Nmap \u2192 Nuclei)</li> <li>Conditional workflows and multi-stage task logic</li> <li>Reusable scan templates with structured logic</li> </ul>"},{"location":"installation/","title":"Installation","text":"<p>Falcoria is built as a modular system. Each component serves a specific role, and you only need to install what fits your use case.</p> <p>At this stage, two public modules are available:</p>"},{"location":"installation/#scanledger","title":"ScanLedger","text":"<p>ScanLedger is the backend responsible for storing, organizing, and querying scan results. It does not execute scans \u2014 but gives you full access to reports, project data, and import functionality.</p> <p>\u2192 ScanLedger Installation Guide</p>"},{"location":"installation/#falcli-cli-client","title":"falcli (CLI Client)","text":"<p><code>falcli</code> is the command-line interface to manage projects, import data, and interact with ScanLedger. Use it to test workflows, automate project setup, or simulate scans manually.</p> <p>\u2192 CLI Installation Guide</p> <p>\u26a0\ufe0f Other modules such as <code>Tasker</code> and <code>Worker</code> (used for actual scanning and distribution) are not yet publicly released.</p>"},{"location":"quick-start/","title":"Quick Start","text":"<p>This guide provides two streamlined ways to get started with Falcoria: a high-level automatic workflow using <code>fast-scan</code>, and a more manual, step-by-step process for full control.</p> <p>\u2699\ufe0f This guide uses <code>falcli</code> \u2014 Falcoria's command-line interface. Make sure it\u2019s installed and connected to a running backend before proceeding.</p>"},{"location":"quick-start/#option-1-fast-path-with-fast-scan","title":"Option 1: Fast Path with <code>fast-scan</code>","text":"<p>Use this when you want to scan quickly with minimal setup.</p> <pre><code>falcli fast-scan --config scan_configs/default.yaml --hosts example.com,scanme.nmap.org\n</code></pre> <p>The command above will:</p> <ul> <li>Create a new project with a random name</li> <li>Send a scan request to Tasker</li> <li>Track progress until completion</li> <li>Show scanned IPs and port summary</li> <li>Save report locally (XML by default)</li> </ul> <p>You can also pass <code>--delete</code> if you want to remove the project after report download.</p> <p>Example config files can be found in the <code>scan_configs</code> folder or created manually.</p>"},{"location":"quick-start/#option-2-manual-step-by-step-control","title":"Option 2: Manual Step-by-Step Control","text":"<p>Use this when you want explicit control over project creation, task sending, and data download.</p>"},{"location":"quick-start/#1-create-project","title":"1. Create Project","text":"<pre><code>falcli project create --name internal-net\n</code></pre>"},{"location":"quick-start/#2-start-scan","title":"2. Start Scan","text":"<pre><code>falcli project scan start --config scan_configs/custom.yaml --hosts example.com,scanme.nmap.org\n</code></pre>"},{"location":"quick-start/#3-check-scan-status","title":"3. Check Scan Status","text":"<pre><code>falcli project scan status\n</code></pre>"},{"location":"quick-start/#4-get-scanned-ips","title":"4. Get Scanned IPs","text":"<pre><code>falcli project ips list\n</code></pre>"},{"location":"quick-start/#5-download-report","title":"5. Download Report","text":"<pre><code>falcli project ips download\n</code></pre> <p>This manual workflow gives you full control over scope, mode, configuration, and report handling.</p>"},{"location":"use-cases/","title":"Falcoria Use Cases","text":"<p>Falcoria supports a wide range of real-world workflows through two primary categories:</p> <ul> <li>Scan Strategies \u2013 how scans are executed</li> <li>Report Handling \u2013 how scan results are imported, enriched, or merged</li> </ul> <p>This document outlines the most essential use cases for the MVP release.</p>"},{"location":"use-cases/#1-scan-strategies","title":"1. Scan Strategies","text":""},{"location":"use-cases/#port-sharding-across-workers","title":"Port Sharding Across Workers","text":"<p>Distribute port ranges across multiple workers to parallelize scans and reduce detection by IDS/IPS.</p> <pre><code>falcli fast-scan --config ports_0-10000.yaml --hosts targets.txt\nfalcli fast-scan --config ports_10001-65535.yaml --hosts targets.txt\n</code></pre> <p>Import Mode: <code>append</code></p> <p>\u26a0\ufe0f To ensure optimal task distribution, launch the scans one by one with short delays between commands. This gives workers time to claim tasks without conflicts.</p>"},{"location":"use-cases/#fast-scan-only-no-service-detection","title":"Fast Scan Only (No Service Detection)","text":"<p>Run a lightweight scan to detect open ports quickly, skipping service detection entirely.</p> <p>Why This Matters:</p> <ul> <li>Speeds up scanning time, especially for large scopes</li> <li>Minimizes noise to avoid detection by firewalls, IDS, and honeypots</li> <li>Allows chaining with external tools for post-processing</li> </ul> <pre><code>falcli fast-scan --config fast_ports.yaml --hosts targets.txt\n</code></pre>"},{"location":"use-cases/#service-detection-behavior-default-and-optional","title":"Service Detection Behavior (Default and Optional)","text":"<p>By default, Falcoria first discovers open ports and then performs service detection for those ports.</p> <ul> <li>You can disable service detection in the configuration file to run only the discovery phase.</li> <li>Falcoria saves open ports found during the first phase.</li> <li>If some ports are later closed (e.g., by firewall rules) during service detection, they will still be retained in the project.</li> </ul>"},{"location":"use-cases/#offline-project-imports","title":"Offline Project Imports","text":"<p>Useful for air-gapped or internal environments where scan results are collected manually.</p> <p>Why This Matters:</p> <ul> <li>Supports internal pentests or red team ops without internet access</li> <li>Integrates legacy tool output (e.g., Nmap XML)</li> <li>Still benefits from Falcoria\u2019s deduplication and import logic</li> </ul> <pre><code>falcli project ips import --file scan.xml --mode insert\n</code></pre>"},{"location":"use-cases/#2-report-handling","title":"2. Report Handling","text":""},{"location":"use-cases/#enrich-partial-results","title":"Enrich Partial Results","text":"<p>First import open ports only, then later import banners or services to update only changed fields.</p> <pre><code>falcli project ips import --file service_scan.xml --mode update\n</code></pre> <p>Import Mode: <code>update</code></p>"},{"location":"use-cases/#replace-changed-hosts","title":"Replace Changed Hosts","text":"<p>If a rescan reveals different open ports, fully replace the corresponding host\u2019s data.</p> <p>Why This Matters:</p> <ul> <li>During long engagements, the network state may change frequently</li> <li>Ensures the scan data stays fresh and relevant</li> <li>Eliminates outdated results without manual cleanup</li> </ul> <pre><code>falcli project ips import --file latest_scan.xml --mode replace\n</code></pre> <p>Import Mode: <code>replace</code></p>"},{"location":"use-cases/#initial-import-and-deduplication","title":"Initial Import and Deduplication","text":"<p>Safely load scan results into a project. Whether importing manually or via workers, the backend ensures that no duplicate IP-port pairs are stored. This avoids redundancy when multiple team members scan the same targets.</p> <p>Why This Matters:</p> <ul> <li>Reduces storage overhead</li> <li>Ensures clean project history</li> <li>Prevents conflicts in collaborative workflows</li> </ul> <pre><code>falcli fast-scan --hosts team1.txt --mode insert\nfalcli project ips import --file external_team_scan.xml --mode insert\n</code></pre> <p>Import Mode: <code>insert</code> or <code>update</code></p> <p>These core use cases define the MVP-level capabilities of Falcoria. They ensure efficient scanning, parallel execution, clean data management, and reliable collaboration.</p>"},{"location":"import-modes/","title":"Import Modes in Falcoria","text":"<p>Import modes are the heart of Falcoria\u2019s scan management system \u2014 giving you full control over how scan data is ingested, updated, and preserved. They apply equally to automated scan results (e.g. scans) and to manual imports (e.g. from Nmap XML reports). They ensure consistency, eliminate duplicates, and support workflows like incremental enrichment or authoritative replacement.</p>"},{"location":"import-modes/#quick-access","title":"Quick Access","text":"<ul> <li><code>insert</code> Mode \u2013 Example</li> <li><code>replace</code> Mode \u2013 Example</li> <li><code>append</code> Mode</li> <li><code>update</code> Mode</li> </ul>"},{"location":"import-modes/#summary-table","title":"Summary Table","text":"Mode What it Does Primary Use Case <code>insert</code> Adds new IPs only; skips if they exist Importing multiple partial scans safely without risk of duplication <code>replace</code> Deletes and replaces all matching IPs and ports Overwriting outdated scan results with fresh authoritative data <code>append</code> Adds new ports to existing IPs; does not update existing ones Combining distributed or parallel scans into one dataset <code>update</code> Updates only matching ports; preserves everything else Enriching scan data incrementally (e.g. banners, versions)"},{"location":"import-modes/#when-to-use-each-mode","title":"When to Use Each Mode","text":"<p>Each import mode exists to support a specific type of workflow. Here\u2019s how to decide:</p> <ul> <li> <p>Insert \u2192 \u201cI don\u2019t want to mess up what\u2019s there; just add new stuff.\u201d   Useful when importing scan chunks safely without affecting existing results.</p> </li> <li> <p>Replace \u2192 \u201cI want to start over for this host.\u201d   Clears out stale or incorrect data and replaces it completely.</p> </li> <li> <p>Append \u2192 \u201cThis is more data for the same host \u2014 don\u2019t touch what\u2019s already known.\u201d   Designed for phased scanning or port sharding across teams or tools.</p> </li> <li> <p>Update \u2192 \u201cLet\u2019s improve the quality of the scan details, not the structure.\u201d   Keeps the structure intact but adds more detail where available.</p> </li> </ul> <p>Note: All import modes will add new IP addresses that don\u2019t already exist in the project \u2014 this behavior is consistent across <code>insert</code>, <code>replace</code>, <code>append</code>, and <code>update</code>.</p> <p>Use these modes to control how data enters Falcoria and to design scanning workflows that match your infrastructure and goals.</p>"},{"location":"import-modes/append/","title":"<code>append</code> Mode","text":"<p>The <code>append</code> mode lets you add new ports to existing IPs without touching or modifying existing data. It\u2019s designed for parallel scans, port sharding, and multi-phase collection \u2014 where multiple scan outputs need to be combined into one project.</p> <p>This mode avoids any destructive behavior and is ideal when you want to gather more data over time.</p>"},{"location":"import-modes/append/#when-to-use-append","title":"\u2705 When to Use <code>append</code>","text":"<p>Use this mode when:</p> <ul> <li>You're combining partial results from multiple scan agents</li> <li>You're scanning different port ranges in separate phases</li> <li>You're running parallel workers to cover large IP scopes faster</li> <li>You're layering additional scan data (e.g. slow services or UDP) without disturbing existing results</li> </ul>"},{"location":"import-modes/append/#behavior-summary","title":"\ud83e\udde0 Behavior Summary","text":"<ul> <li>If an IP does not exist in the project \u2192 it will be added</li> <li>If an IP exists \u2192 new ports will be added, but existing ports stay unchanged</li> <li>Fields like <code>banner</code>, <code>service</code>, and metadata remain untouched for existing ports</li> </ul>"},{"location":"import-modes/append/#safe-by-design","title":"\ud83d\udee1 Safe by Design","text":"<p>No existing data is modified or removed. <code>append</code> is fully additive \u2014 making it the best choice for distributed scan merging.</p>"},{"location":"import-modes/append/#example","title":"\ud83d\udca1 Example","text":"<pre><code>python3 falcli.py project ips import --file report_append1.xml --mode append\n</code></pre> <p>Output:</p> <pre><code>Imported IPs report into project 'example-project-id'. Result: 1 IP.\n</code></pre> <p>After importing <code>report_append2.xml</code>, new ports will appear \u2014 without altering previously added ones.</p>"},{"location":"import-modes/append/#try-it-yourself","title":"\ud83d\udd17 Try It Yourself","text":"<ul> <li>Step-by-Step Example on GitHub</li> </ul>"},{"location":"import-modes/insert/","title":"<code>insert</code> Mode","text":"<p>The <code>insert</code> mode is the safest way to import scan results into a Falcoria project. It adds new IPs and their data only if they do not already exist \u2014 and skips duplicates silently.</p> <p>This makes it ideal for importing results from passive scans, segmented scopes, or slow asset discovery \u2014 where you don\u2019t want to accidentally overwrite or duplicate anything already collected.</p>"},{"location":"import-modes/insert/#when-to-use-insert","title":"\u2705 When to Use <code>insert</code>","text":"<p>Use this mode when:</p> <ul> <li>You're importing scan data from multiple small or partial scans</li> <li>You want to avoid modifying any existing project data</li> <li>You\u2019re loading results from distributed scanning agents or external sources</li> <li>You\u2019re transferring scans from an isolated or offline network environment where direct integration isn\u2019t possible</li> </ul>"},{"location":"import-modes/insert/#behavior-summary","title":"\ud83e\udde0 Behavior Summary","text":"<ul> <li>If an IP does not exist in the project \u2192 it will be added</li> <li>If an IP already exists \u2192 it will be skipped without error</li> <li>Ports are only added for new IPs; existing IPs and their ports remain untouched</li> </ul>"},{"location":"import-modes/insert/#example","title":"\ud83d\udca1 Example","text":"<pre><code>python3 falcli.py project ips import --file report_insert1.xml --mode insert\n</code></pre> <p>Output:</p> <pre><code>Imported IPs report into project 'example-project-id'. Result: 2 IPs.\n</code></pre> <p>If you run it again with the same file, it will detect duplicates and skip them:</p> <pre><code>No new IPs added in project \n</code></pre>"},{"location":"import-modes/insert/#try-it-yourself","title":"\ud83d\udd17 Try It Yourself","text":"<ul> <li>Step-by-Step Example on GitHub</li> </ul>"},{"location":"import-modes/replace/","title":"<code>replace</code> Mode","text":"<p>The <code>replace</code> mode is a destructive import mode \u2014 it fully removes and replaces existing data for matching IPs. If an IP already exists in the project, it will be wiped clean (including all ports and metadata) and replaced with the data from the new report.</p> <p>Use this mode when you want to overwrite outdated or incorrect scan results with fresh, authoritative data.</p>"},{"location":"import-modes/replace/#when-to-use-replace","title":"\u2705 When to Use <code>replace</code>","text":"<p>Use this mode when:</p> <ul> <li>You're resyncing results from a more complete or trusted scan</li> <li>You need to clean up bad or partial scan data</li> <li>You\u2019re running a re-scan and want to discard old port states</li> <li>You\u2019re enforcing source-of-truth data from a central scan server</li> </ul>"},{"location":"import-modes/replace/#behavior-summary","title":"\ud83e\udde0 Behavior Summary","text":"<ul> <li>If an IP does not exist in the project \u2192 it will be added normally</li> <li>If an IP already exists \u2192 its entire record will be deleted and replaced</li> <li>Port and metadata fields are wiped and re-imported in full</li> </ul>"},{"location":"import-modes/replace/#warning","title":"\u26a0\ufe0f Warning","text":"<p><code>replace</code> is not reversible. Once imported, previous data is lost unless you have a backup. Use with care, especially in collaborative environments.</p>"},{"location":"import-modes/replace/#example","title":"\ud83d\udca1 Example","text":"<pre><code>python3 falcli.py project ips import --file report_replace1.xml --mode replace\n</code></pre> <p>Output:</p> <pre><code>Imported IPs report into project 'example-project-id'. Result: 1 IP.\n</code></pre>"},{"location":"import-modes/replace/#try-it-yourself","title":"\ud83d\udd17 Try It Yourself","text":"<ul> <li>Step-by-Step Example on GitHub</li> </ul>"},{"location":"import-modes/update/","title":"<code>update</code> Mode","text":"<p>The <code>update</code> mode allows you to enrich or refine existing scan data without overwriting the entire IP record. It performs a smart field-level merge \u2014 updating only the values that are explicitly present in the new report.</p> <p>This is perfect for progressive scanning, banner grabbing, or incrementally improving service detection.</p>"},{"location":"import-modes/update/#when-to-use-update","title":"\u2705 When to Use <code>update</code>","text":"<p>Use this mode when:</p> <ul> <li>You're enriching data with additional scan phases (e.g. version detection)</li> <li>You're merging passive and active results for the same IPs</li> <li>You're updating banners, services, or OS details from more specialized tools</li> <li>You want to preserve existing port data while refining metadata</li> </ul>"},{"location":"import-modes/update/#behavior-summary","title":"\ud83e\udde0 Behavior Summary","text":"<ul> <li>If an IP does not exist in the project \u2192 it will be added</li> <li>If an IP exists \u2192 its ports stay intact; only fields explicitly present in the import are updated</li> <li>Fields that are missing in the import report will not erase or overwrite existing data</li> </ul>"},{"location":"import-modes/update/#smart-merge-logic","title":"\ud83e\udde0 Smart Merge Logic","text":"<p>Unlike <code>replace</code>, which wipes everything, <code>update</code> is non-destructive and selective. It\u2019s ideal for long-term scan enrichment, especially when combining different tools or scan passes.</p>"},{"location":"import-modes/update/#example","title":"\ud83d\udca1 Example","text":"<pre><code>python3 falcli.py project ips import --file report_update1.xml --mode update\n</code></pre> <p>Output:</p> <pre><code>Imported IPs report into project 'example-project-id'. Result: 1 IP.\n</code></pre> <p>Existing port data will remain, but service names or banners may be updated.</p>"},{"location":"import-modes/update/#try-it-yourself","title":"\ud83d\udd17 Try It Yourself","text":"<ul> <li>Step-by-Step Example on GitHub</li> </ul>"},{"location":"installation/falcli/","title":"Falcoria CLI \u2013 Installation Guide","text":"<p>Falcoria CLI (<code>falcli</code>) is the command-line interface for configuring and managing distributed scans through the Falcoria platform. This guide covers installation and setup of the CLI tool only.</p> <p>Note: The CLI requires a running Falcoria backend (ScanLedger, Tasker, Redis, RabbitMQ). This guide does not include backend deployment steps.</p>"},{"location":"installation/falcli/#requirements","title":"Requirements","text":"<ul> <li>Python 3.8 or higher</li> <li>Git</li> <li>Linux or macOS (Windows is supported via WSL or Python virtualenv)</li> </ul>"},{"location":"installation/falcli/#installation-steps","title":"Installation Steps","text":"<pre><code># Clone the repository\ngit clone https://github.com/Falcoria/falcli.git\ncd falcli\n\n# Create and activate a virtual environment\npython3 -m venv venv\nsource venv/bin/activate  # On Windows: venv\\Scripts\\activate\n\n# Install dependencies\npip install -r requirements.txt\n\n# Verify installation\npython3 falcli.py\n</code></pre>"},{"location":"installation/falcli/#cli-overview","title":"CLI Overview","text":"<pre><code>Usage: falcli.py [OPTIONS] COMMAND [ARGS]...\n\nOptions:\n  --version, -v             Show the version and exit.\n  --install-completion      Install shell completion.\n  --show-completion         Show shell completion info.\n  --help                    Show this message and exit.\n\nCommands:\n  fast-scan   Start a quick scan, track it, and download report\n  project     Manage projects and IP data.\n  config      Configure CLI settings and backend URLs.\n  memory      View or clear stored memory state.\n  scan        Start, stop, or preview scans.\n  workers     Manage worker nodes and their IPs.\n</code></pre>"},{"location":"installation/scanledger/","title":"ScanLedger \u2013 Installation Guide","text":"<p>ScanLedger is the backend API and data store powering Falcoria's scan ingestion and querying engine.</p> <p>You can install it using one of the following methods:</p> <ul> <li>Virtual Environment (Development Setup)</li> <li>Docker (Using Public Image)</li> <li>Docker (Local Build)</li> <li>Docker Compose (Recommended for Self-Hosting)</li> </ul>"},{"location":"installation/scanledger/#installation-methods","title":"Installation Methods","text":""},{"location":"installation/scanledger/#1-virtual-environment-development-setup","title":"1. Virtual Environment (Development Setup)","text":"<p>Use this method for development or debugging:</p> <pre><code>git clone https://github.com/Falcoria/scanledger.git\ncd scanledger\n\npython3 -m venv venv\nsource venv/bin/activate\n\npip install --upgrade pip\npip install -r requirements.txt\n\ncp .env.example .env\nnano .env  # Configure DB and tokens\n\nuvicorn app.main:app --host 0.0.0.0 --port 8000\n</code></pre> <p>API will be available at <code>https://localhost:8000/docs</code>.</p>"},{"location":"installation/scanledger/#2-docker-using-public-image","title":"2. Docker (Using Public Image)","text":"<p>Generate TLS certificates (optional for HTTPS):</p> <pre><code>./generate-tls-bundle.sh\n</code></pre> <p>Run the container:</p> <pre><code>docker run -d \\\n  --name scanledger \\\n  -p 443:443 \\\n  -e POSTGRES_USER=postgres \\\n  -e POSTGRES_PASSWORD=changeme \\\n  -e POSTGRES_DB=falcoriadb \\\n  -e POSTGRES_HOST=localhost \\\n  -e ENVIRONMENT=development \\\n  -e ADMIN_TOKEN=changeme \\\n  -e TASKER_TOKEN=changeme \\\n  -v $(pwd)/unit/bundle.pem:/docker-entrypoint.d/bundle.pem:ro \\\n  ghcr.io/falcoria/scanledger:latest\n</code></pre>"},{"location":"installation/scanledger/#3-docker-local-build","title":"3. Docker (Local Build)","text":"<pre><code>git clone https://github.com/Falcoria/scanledger.git\ncd scanledger\n\n./generate-tls-bundle.sh\n\ndocker build -t scanledger .\n\ndocker run -d \\\n  --name scanledger \\\n  -p 443:443 \\\n  -e POSTGRES_USER=postgres \\\n  -e POSTGRES_PASSWORD=changeme \\\n  -e POSTGRES_DB=falcoriadb \\\n  -e POSTGRES_HOST=localhost \\\n  -e ENVIRONMENT=development \\\n  -e ADMIN_TOKEN=changeme \\\n  -e TASKER_TOKEN=changeme \\\n  -v $(pwd)/unit/bundle.pem:/docker-entrypoint.d/bundle.pem:ro \\\n  scanledger\n</code></pre>"},{"location":"installation/scanledger/#4-docker-compose-recommended-for-self-hosting","title":"4. Docker Compose (Recommended for Self-Hosting)","text":"<pre><code>git clone https://github.com/Falcoria/scanledger.git\ncd scanledger\ncp .env.example .env  # Edit the variables below\n\ndocker compose up --build\n</code></pre> <p>Access: https://localhost:443</p>"},{"location":"installation/scanledger/#config-reference","title":"Config Reference","text":"Variable Description <code>POSTGRES_USER</code> Postgres login name <code>POSTGRES_PASSWORD</code> Postgres password <code>POSTGRES_DB</code> Name of the database used by ScanLedger <code>POSTGRES_HOST</code> Network host/IP of your Postgres instance <code>ENVIRONMENT</code> App mode (e.g. <code>development</code>, affects error verbosity) <code>ADMIN_TOKEN</code> Token used to create the default admin user (used for authorization in API calls) <code>TASKER_TOKEN</code> Token used by the Tasker module (not critical in self-hosted setups)"},{"location":"installation/scanledger/#api-example","title":"API Example","text":"<p>Create a project via curl:</p> <pre><code>curl -X POST https://localhost:443/projects \\\n  -H \"Authorization: Bearer &lt;YOUR_AUTH_TOKEN&gt;\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"project_name\": \"example-project\", \"comment\": \"Initial test\"}' \\\n  --insecure\n</code></pre> <p>Or using <code>falcli</code>:</p> <pre><code>python3 falcli.py project create example-project\n</code></pre>"},{"location":"installation/scanledger/#license","title":"License","text":"<p>MIT License \u2013 See <code>LICENSE.md</code> for full terms.</p>"},{"location":"use-cases/","title":"Falcoria Use Cases","text":"<p>Falcoria supports structured workflows for scanning, importing, filtering, and managing scan results. This section documents common usage patterns and provides real-world CLI sequences for each.</p> <p>Each use case reflects actual red team and recon workflows \u2014 from fast scans to controlled project management.</p>"},{"location":"use-cases/#cli-patterns","title":"CLI Patterns","text":"<p>These commands form the base of interaction:</p> <ul> <li><code>create</code> \u2014 create new projects or scan jobs</li> <li><code>list</code> \u2014 list projects, IPs, ports, or results</li> <li><code>get</code> \u2014 retrieve detailed data per asset or scan</li> <li><code>delete</code> \u2014 remove data cleanly from the system</li> <li><code>help</code> \u2014 introspect available commands and options</li> </ul>"},{"location":"use-cases/#scan-behavior-note","title":"Scan Behavior Note","text":"<p>By default, Falcoria performs open port detection first, and then automatically runs service scan only on ports that are confirmed open.</p> <ul> <li>You can disable service scanning entirely if you only want to detect open ports.</li> <li>You cannot currently run only service scans on pre-specified ports without first performing port discovery.</li> </ul> <p>This approach optimizes performance and minimizes noise while preserving accurate state information for import and merge operations.</p>"},{"location":"use-cases/#scan-configs-reference","title":"Scan Configs Reference","text":"<p>Falcoria uses YAML-based configuration files to control scan behavior.</p> <ul> <li>Use predefined configs from <code>scan_configs/</code></li> <li>See full option list in <code>all_options.yaml</code></li> <li>Short configs like <code>light.yaml</code> or <code>web.yaml</code> are available for quick targeting</li> <li>Configs can be shared, versioned, or chained across scan phases</li> </ul>"},{"location":"use-cases/#use-cases-covered","title":"Use Cases Covered","text":"<ul> <li> <p>Common Workflow   Typical create/list/get/delete commands for working with projects, IPs, and ports.</p> </li> <li> <p>Import External Reports   Add Nmap XML results to your project scope \u2014 no workers needed.</p> </li> <li> <p>Rescan   Trigger new scans on previously discovered IPs or ports.</p> </li> <li> <p>Update Enrichment   Enrich or reclassify services with newer metadata (e.g., updated banners).</p> </li> <li> <p>Port Sharding (Evasion)   Use parallelized port scan ranges to bypass WAFs and reduce detection.</p> </li> </ul>"},{"location":"use-cases/common-workflow/","title":"Common Workflow","text":"<p>This section provides the typical workflow for using Falcoria \u2014 from project creation to scanning, status checks, results retrieval, and cleanup.</p>"},{"location":"use-cases/common-workflow/#1-create-a-project","title":"1. Create a Project","text":"<p>All scanned data and related information in Falcoria are grouped under projects. This allows clear separation of different assessments.</p> <p>To create a project:</p> <pre><code>./falcli.py project create pentest_project\n</code></pre> <p>Example output:</p> <pre><code>[+] Project 'pentest_project' created successfully (26e73c7f-c1e3-4131-8ee5-99a01681af9f).\n  project_name  : pentest_project\n  id            : 26e73c7f-c1e3-4131-8ee5-99a01681af9f\n  users         : admin\nFirst project saved.\n</code></pre> <p>To set the active project:</p> <pre><code>./falcli.py project set-active &lt;uuid&gt;\n</code></pre> <p>List all projects stored on the server:</p> <pre><code>./falcli.py project list\n</code></pre>"},{"location":"use-cases/common-workflow/#2-start-a-scan","title":"2. Start a Scan","text":"<p>To launch a scan for the active project:</p> <pre><code>./falcli.py scan start --targets-file hosts.txt\n</code></pre> <p>Example output:</p> <pre><code>[+] Scan initiated for project: 'pentest_project' (26e73c7f-c1e3-4131-8ee5-99a01681af9f).\n\nScan Settings\n  Import mode        : insert\n  Nmap (open ports)  : -n --max-retries 1 --min-rate 300 -Pn -p 1-65535\n  Nmap (services)    : -sV -Pn\n  Scan config        : app/data/scan_configs/default.yaml\n\nScan Summary\n  Targets provided         : 6\n  Duplicates removed       : 1\n  Skipped (already known)  : 0\n  Rejected                 : 0\n  Accepted and sent        : 5\n</code></pre> <p>To use a different scan configuration:</p> <pre><code>./falcli.py scan start --config ./app/data/scan_configs/web.yaml --targets-file hosts.txt\n</code></pre> <p>By default, Falcoria skips targets that were already scanned within the project. Only new, unknown hosts are accepted.</p> <p>To re-scan all targets regardless of previous results, use replace mode. See details here.</p> <p>All available scan options can be reviewed in:</p> <pre><code>./app/data/scan_configs/all_options_example.yaml\n</code></pre> <p>Before launching a scan, check available workers:</p> <pre><code>./falcli.py workers ips\n</code></pre> <p>Example output:</p> <pre><code>[+] Fetched external IP addresses of active workers.\n\nHOSTNAME      IP               LAST_UPDATED         LAST_UPDATED_AGO\nd2b5c09fe876  134.209.200.222  2025-06-26 15:44:02  25 min ago\nc21da8b747db  146.190.27.214   2025-06-26 15:44:02  25 min ago\ne323a82d28d3  159.223.225.154  2025-06-26 15:44:02  25 min ago\na5ef4e44ca7b  64.225.64.155    2025-06-26 15:44:02  25 min ago\n\n4 workers online.\n</code></pre> <p>Each worker processes one host at a time.</p>"},{"location":"use-cases/common-workflow/#3-scan-status","title":"3. Scan Status","text":"<p>To check current scan status:</p> <pre><code>./falcli.py scan status\n</code></pre> <p>Example output:</p> <pre><code>[+] Scan status for project 26e73c7f-c1e3-4131-8ee5-99a01681af9f fetched successfully.\n\nScan Status Summary\n  Tasks total    : 5\n  Tasks running  : 4\n  Tasks queued   : 1\n\nRunning Targets:\nIP               HOSTNAMES  WORKER        STARTED_AT (UTC)     ELAPSED\n142.93.156.194              a5ef4e44ca7b  2025-06-29 17:24:28  0:00:10\n147.182.157.118             d2b5c09fe876  2025-06-29 17:24:28  0:00:10\n143.110.223.7               e323a82d28d3  2025-06-29 17:24:28  0:00:10\n165.22.231.248              c21da8b747db  2025-06-29 17:24:28  0:00:10\n</code></pre> <p>For interactive status with auto-refresh:</p> <pre><code>./falcli.py scan status -i\n</code></pre> <p>Example interactive output:</p> <pre><code>Scan status for project 'pentest_project' (26e73c7f-c1e3-4131-8ee5-99a01681af9f) fetched successfully.\n\nScan Status Summary\n  Tasks total    : 5\n  Tasks running  : 4\n  Tasks queued   : 1\n\nRunning Targets:\nIP               HOSTNAMES  WORKER        STARTED_AT (UTC)     ELAPSED\n142.93.156.194              a5ef4e44ca7b  2025-06-29 17:24:28  0:00:10\n147.182.157.118             d2b5c09fe876  2025-06-29 17:24:28  0:00:10\n143.110.223.7               e323a82d28d3  2025-06-29 17:24:28  0:00:10\n165.22.231.248              c21da8b747db  2025-06-29 17:24:28  0:00:10\n\nRemaining: 5/5 | Elapsed: 5s\n</code></pre>"},{"location":"use-cases/common-workflow/#4-stop-scan","title":"4. Stop Scan","text":"<p>To stop an active scan and terminate all Nmap processes:</p> <pre><code>./falcli.py scan stop\n</code></pre> <p>Example output:</p> <pre><code>[+] Scan stopped successfully for project: 'pentest_project' (26e73c7f-c1e3-4131-8ee5-99a01681af9f).\nRevoked 5 tasks.\n</code></pre> <p>If some hosts were partially scanned, re-running the scan will skip already scanned hosts automatically.</p>"},{"location":"use-cases/common-workflow/#5-get-scan-results","title":"5. Get Scan Results","text":"<p>List results:</p> <pre><code>./falcli.py project ips get\n</code></pre> <p>Download results:</p> <pre><code>./falcli.py project ips download\n</code></pre> <p>Example output:</p> <pre><code>[Active Project]: 'pentest_project' (26e73c7f-c1e3-4131-8ee5-99a01681af9f)\n[+] Downloaded IPs report for project '26e73c7f-c1e3-4131-8ee5-99a01681af9f'.\nSaved to: app/data/reports/26e73c7f-c1e3-4131-8ee5-99a01681af9f_ips.xml\n</code></pre>"},{"location":"use-cases/common-workflow/#6-delete-data","title":"6. Delete Data","text":"<p>To delete all scanned IPs from the project:</p> <pre><code>./falcli.py project ips delete\n</code></pre> <p>To delete the entire project:</p> <pre><code>./falcli.py project delete &lt;uuid&gt;\n</code></pre> <p>This operation removes project data completely from the server.</p> <p>This represents the essential workflow in Falcoria \u2014 project setup, scanning, monitoring, retrieving results, and cleaning up.</p>"},{"location":"use-cases/deduplication-behavior/","title":"Deduplication Behavior","text":"<p>Falcoria applies deduplication at multiple stages of the scanning workflow. This ensures efficient resource usage, consistent scan results, and seamless support for resuming interrupted scans. This document describes how deduplication works both during the import of external scan reports and during the scan phase itself.</p>"},{"location":"use-cases/deduplication-behavior/#deduplication-during-scan-report-imports","title":"Deduplication During Scan Report Imports","text":"<p>When importing external Nmap reports, Falcoria uses import modes to control how incoming data is merged with existing results. These modes prevent duplication of previously scanned ports, IPs, or entries that match known states.</p> <p>The deduplication logic depends entirely on the selected import mode. For example:</p> <ul> <li><code>insert</code> will skip any existing entries</li> <li><code>replace</code> will remove and overwrite previous data</li> <li><code>update</code> only modifies ports that already exist</li> </ul> <p>To understand these behaviors in depth, see the following resources:</p> <ul> <li>Import External Reports Use Case</li> <li>Import Modes Overview</li> </ul>"},{"location":"use-cases/deduplication-behavior/#why-deduplication-matters","title":"Why Deduplication Matters","text":"<p>Falcoria\u2019s deduplication mechanisms are critical for:</p> <ul> <li>Reducing scan duration by avoiding repeated work</li> <li>Preventing duplicate entries in the project database</li> <li>Minimizing network and system load</li> <li>Enabling scan resumption without reconfiguration or manual filtering</li> </ul> <p>Once a host is scanned or queued, Falcoria will skip it on repeated execution of the same scan command. This allows the system to resume scans from where they stopped and prevents duplicate tasks from being created.</p>"},{"location":"use-cases/deduplication-behavior/#deduplication-during-scanning","title":"Deduplication During Scanning","text":"<p>Falcoria applies three layers of deduplication during the scan phase:</p>"},{"location":"use-cases/deduplication-behavior/#1-deduplication-of-user-provided-hosts","title":"1. Deduplication of User-Provided Hosts","text":"<p>If the user supplies a target file that contains duplicate entries, only unique hosts will be accepted. The deduplication occurs at the Tasker level before queueing begins.</p> <p>Example: Hosts file with duplicates <pre><code>$ cat hosts_with_duplicates.txt\n159.223.15.22\n159.223.15.22\n188.166.121.245\n</code></pre></p> <p>Scan execution after input deduplication <pre><code>$ ./falcli.py scan start --targets-file hosts_with_duplicates.txt\n[+] Scan targets sent for project 4e0d5a24-791d-4abb-a1fd-212f738b48b8.\n[+] Sent to scan:\n  - 159.223.15.22\n  - 188.166.121.245\n</code></pre></p>"},{"location":"use-cases/deduplication-behavior/#2-deduplication-against-queued-targets","title":"2. Deduplication Against Queued Targets","text":"<p>If a host is already queued for scanning and the same target is submitted again, Falcoria will reject it without duplication. This prevents redundant load and preserves system efficiency.</p> <p>Initial scan submission <pre><code>$ ./falcli.py scan start --targets-file hosts.txt\n[+] Scan targets sent for project 4e0d5a24-791d-4abb-a1fd-212f738b48b8.\n[+] Sent to scan:\n  - 188.166.121.245\n  - 128.199.62.51\n  - 159.223.15.22\n  - 134.209.203.62\n</code></pre></p> <p>Verifying that targets are already in the scan queue <pre><code>$ ./falcli.py scan status\n[+] Scan status for project 4e0d5a24-791d-4abb-a1fd-212f738b48b8: 4\n</code></pre></p> <p>Re-submitting the same targets <pre><code>$ ./falcli.py scan start --targets-file hosts.txt\n[+] Scan targets sent for project 4e0d5a24-791d-4abb-a1fd-212f738b48b8.\n[!] No targets were accepted for scanning.\n[!] Rejected targets:\n  - 188.166.121.245\n  - 128.199.62.51\n  - 159.223.15.22\n  - 134.209.203.62\n</code></pre></p>"},{"location":"use-cases/deduplication-behavior/#3-deduplication-against-previously-scanned-hosts","title":"3. Deduplication Against Previously Scanned Hosts","text":"<p>Falcoria checks the project\u2019s scan history in ScanLedger. If a host has already been scanned and recorded in the database, it will not be accepted for scanning again using the same command and project context.</p> <p>Database contents <pre><code>$ ./falcli.py project ips list\nIP               PORT_COUNT\n128.199.62.51    6         \n134.209.203.62   6         \n159.223.15.22    6         \n188.166.121.245  8         \n</code></pre></p> <p>Attempting to rescan the same IPs <pre><code>$ cat hosts.txt\n134.209.203.62\n159.223.15.22\n188.166.121.245\n128.199.62.51\n\n$ ./falcli.py scan start --targets-file hosts.txt\n[+] Scan targets sent for project 4e0d5a24-791d-4abb-a1fd-212f738b48b8.\n[!] No targets were accepted for scanning.\n[!] Rejected targets:\n  - 188.166.121.245\n  - 128.199.62.51\n  - 159.223.15.22\n  - 134.209.203.62\n</code></pre></p>"},{"location":"use-cases/deduplication-behavior/#summary","title":"Summary","text":"<p>Falcoria enforces deduplication at the following stages:</p> <ul> <li>When importing external reports</li> <li>When parsing user input</li> <li>When filtering against the current queue</li> <li>When validating against the project\u2019s historical records</li> </ul> <p>These mechanisms work together to prevent waste, accelerate scans, and allow users to safely repeat scan commands without unintended repetition. This makes Falcoria suitable for large-scale, iterative scanning across complex infrastructures.</p>"},{"location":"use-cases/distributed-scan/","title":"Distributed Scanning","text":""},{"location":"use-cases/distributed-scan/#why-distributed-scanning-matters","title":"Why Distributed Scanning Matters","text":"<p>Traditional perimeter scans are limited by:</p> <ul> <li>The number of machines the team can use, and the manual effort needed to merge results.</li> <li>Network bandwidth and latency limits \u2014 or losing accuracy when trying to scan too fast.</li> </ul> <p>Distributed scanning helps overcome these limits by increasing effective network bandwidth while keeping full scan accuracy.</p>"},{"location":"use-cases/distributed-scan/#when-to-use-distributed-scanning","title":"When to Use Distributed Scanning","text":"<p>Use distributed scanning when:</p> <ul> <li>You are scanning a large perimeter (hundreds or thousands of IPs).</li> <li>You want to reduce total scan time by a factor of 10 or more \u2014 from days to hours or minutes.</li> <li>You want to collect all scan results in one place, fully consolidated.</li> <li>You want to run scans from machines closer to specific targets to reduce latency and improve efficiency.</li> </ul>"},{"location":"use-cases/distributed-scan/#behavior-summary","title":"Behavior Summary","text":"<p>The process of a distributed scan in Falcoria looks like this:</p> <ul> <li>The project scope is split into individual scan tasks.</li> <li>Each scan task represents one Nmap scan of one IP with specific scan parameters.</li> <li>Scan tasks are distributed to available scanner workers.</li> <li>Each worker performs its assigned scans and pushes results to ScanLedger.</li> <li>The CLI retrieves consolidated results from ScanLedger when requested.</li> </ul>"},{"location":"use-cases/distributed-scan/#notes","title":"Notes","text":"<ul> <li>Distributed scanning is safe \u2014 each scan task runs exactly as it would locally on a single machine.</li> <li>Scan accuracy is preserved \u2014 results are identical to standard Nmap output.</li> <li>Speed gains depend on the number of workers and the size of the target perimeter.</li> </ul>"},{"location":"use-cases/distributed-scan/#example","title":"Example","text":"<p>Starting a distributed scan:</p> <pre><code>./falcli.py scan start --targets-file targets.txt\n</code></pre> <p>Output:</p> <pre><code>Scan initiated: 200 targets, 8 workers active. Processing started.\n</code></pre> <p>Retrieving scan results:</p> <pre><code>./falcli.py project ips list\n</code></pre>"},{"location":"use-cases/distributed-scan/#try-it-yourself","title":"Try It Yourself","text":"<p>Step-by-step distributed scan example on GitHub.</p>"},{"location":"use-cases/import-external-reports/","title":"Import External Reports","text":"<p>Falcoria supports importing external scan results into your project scope using Nmap XML files. This allows you to use Falcoria as a centralized data store \u2014 even if you don't use workers or automated scanning.</p> <p>This is handled by the ScanLedger component and does not require Falcoria's distributed scanning features. You can use it in offline mode, fully locally, or on a server \u2014 no RabbitMQ, Redis, or workers are needed.</p>"},{"location":"use-cases/import-external-reports/#use-case-centralized-import-system","title":"Use Case: Centralized Import System","text":"<p>Whether you're importing reports from your personal scans or consolidating results from teammates, ScanLedger can act as a public-facing, standalone report registry.</p> <p>ScanLedger Reference: https://github.com/your-org/scanledger</p>"},{"location":"use-cases/import-external-reports/#how-it-works","title":"How It Works","text":"<p>You can run:</p> <pre><code>falcli project ips import --file &lt;report.xml&gt; [--project-id &lt;id&gt;] [--mode &lt;insert|replace|update|append&gt;]\n</code></pre> <ul> <li><code>--file</code> (required): Path to your Nmap XML report.</li> <li><code>--project-id</code> (optional): Defaults to the last used project.</li> <li><code>--mode</code> (optional): Defaults to <code>insert</code>.</li> </ul> <p>If the project is not found in memory, Falcoria will attempt to fetch it from the server and cache it locally.</p>"},{"location":"use-cases/import-external-reports/#import-modes-summary","title":"Import Modes Summary","text":"<p>A brief overview is shown below. For detailed behavior, see Import Modes.</p> Mode Description insert Adds new IPs and ports. Skips anything already present. replace Clears all existing IPs and ports before adding new data. Destructive. update Updates data for already-known IPs and ports. append Adds only new ports to known IPs. Skips existing ones."},{"location":"use-cases/import-external-reports/#common-scenarios","title":"Common Scenarios","text":""},{"location":"use-cases/import-external-reports/#insert-a-fresh-scan","title":"Insert a fresh scan","text":"<pre><code>falcli project ips import --file nmap_report.xml --mode insert\n</code></pre> <p>Use this if your scan contains new IPs or ports that aren\u2019t in the project yet.</p>"},{"location":"use-cases/import-external-reports/#replace-everything-with-new-results","title":"Replace everything with new results","text":"<pre><code>falcli project ips import --file nmap_report.xml --mode replace\n</code></pre> <p>Use with caution. All existing IPs and ports in the project will be deleted before import.</p>"},{"location":"use-cases/import-external-reports/#update-scan-results-for-known-ips","title":"Update scan results for known IPs","text":"<pre><code>falcli project ips import --file nmap_report.xml --mode update\n</code></pre> <p>This will refresh services or states (e.g., port 80 changing from closed to open).</p>"},{"location":"use-cases/import-external-reports/#when-to-use-this","title":"When to Use This","text":"<ul> <li>You scanned something manually and want to bring the results into Falcoria.</li> <li>You're working in a restricted environment without workers or queueing.</li> <li>You\u2019re collaborating and someone shared a scan report.</li> <li>You want to use Falcoria as a structured storage layer for IPs and ports.</li> </ul>"},{"location":"use-cases/port-sharding/","title":"Evasion: Port Sharding","text":"<p>Port sharding is a technique used to evade detection systems and increase scan throughput by splitting the full port range across multiple scan tasks.</p> <p>This is especially effective when the scanning platform distributes tasks to different workers \u2014 each scanning a distinct range of ports.</p>"},{"location":"use-cases/port-sharding/#sharding-setup","title":"Sharding Setup","text":"<p>Two config files are used to implement sharding:</p> <ul> <li><code>port_shard_1.yaml</code> \u2014 contains ports from 1 to 10,000</li> <li><code>port_shard_2.yaml</code> \u2014 contains ports from 10,001 to 65,535</li> </ul> <p>Example usage:</p> <pre><code>falcli scan start --config scan_configs/port_sharding_1.yaml\nfalcli scan start --config scan_configs/port_sharding_2.yaml\n</code></pre> <p>Run both commands in quick succession to distribute scanning load across different workers.</p>"},{"location":"use-cases/port-sharding/#notes","title":"Notes","text":"<ul> <li>These configs use append mode to preserve existing data.</li> <li>Avoid using <code>replace</code> mode unless you intend to fully wipe and reimport.</li> <li>Be careful with <code>min_rate</code> \u2014 overly high values (like 10,000) can flood networks or trigger defenses.</li> <li>This tactic is best suited for red team or stealth scanning scenarios.</li> </ul>"},{"location":"use-cases/rescan/","title":"Full Rescan","text":"<p>This use case demonstrates how to perform a complete rescan of the current project using replace mode.</p> <p>Replace mode wipes all existing IPs and ports in the project and imports only the results from the new scan. This is useful when you want to fully refresh the scan results with updated data.</p>"},{"location":"use-cases/rescan/#configuration-file","title":"Configuration File","text":"<p>Use the following configuration file to run a full scan:</p> <pre><code>open_ports_opts:\n  skip_host_discovery: true\n  dns_resolution: false\n  transport_protocol: tcp\n  max_retries: 3\n  min_rate: 1000\n  ports:\n    - \"1-65535\"\n\nservice_opts:\n  aggressive_scan: false\n  default_scripts: false\n  os_detection: false\n  traceroute: false\n\ntimeout: 1800\nmode: replace\ninclude_services: true  # identify services for open ports\n</code></pre>"},{"location":"use-cases/rescan/#how-to-use","title":"How to Use","text":"<p>Run the scan with:</p> <pre><code>falcli scan start --config scan_configs/rescan.yaml --from-config\n</code></pre>"},{"location":"use-cases/rescan/#notes","title":"Notes","text":"<p>This use case assumes that the current project already has some previously scanned data, such as APIs and port banners. Only in such cases will replace mode be used as intended \u2014 to cleanly override the existing data with new results.</p> <p>\u26a0\ufe0f Be careful when using <code>replace</code> mode. It deletes all data for the project, including IPs. If an IP that previously had ports now returns no results, the old data will be completely overwritten by an empty set.</p> <p>Use this mode only when you're sure you want a full reset of your scan results.</p>"},{"location":"use-cases/scan-configuration/","title":"Configurable Scans and Preset Profiles","text":"<p>Falcoria supports both quick one-liner scans and fully configurable scan definitions. This makes it suitable for fast on-the-fly usage as well as highly controlled, team-wide scanning workflows.</p>"},{"location":"use-cases/scan-configuration/#launch-a-scan-in-one-command","title":"Launch a Scan in One Command","text":"<p>If you want to start scanning immediately, use the <code>fast-scan</code> command with a default configuration:</p> <pre><code>./falcli.py fast-scan --config ./scan_configs/default.yaml\n</code></pre> <p>This launches a scan with balanced parameters that cover typical infrastructure setups.</p>"},{"location":"use-cases/scan-configuration/#use-predefined-scan-configurations","title":"Use Predefined Scan Configurations","text":"<p>Falcoria includes a set of ready-to-use configuration files that you can use as-is or modify:</p> <ul> <li><code>default.yaml</code> \u2013 general-purpose scan profile</li> <li><code>web.yaml</code> \u2013 focuses on web-related ports</li> <li><code>only_open_ports.yaml</code> \u2013 hides closed/filtered ports in results</li> <li><code>port_sharding_1.yaml</code> / <code>port_sharding_2.yaml</code> \u2013 optimized for distributed scan workers</li> <li><code>rescan.yaml</code> \u2013 forces re-scan of previously scanned targets</li> <li><code>udp.yaml</code> \u2013 enables UDP scanning</li> <li><code>update_enrichment.yaml</code> \u2013 used for scan enrichment or patching</li> </ul> <p>Browse the full list here: scan_configs</p>"},{"location":"use-cases/scan-configuration/#create-your-own-configuration-file","title":"Create Your Own Configuration File","text":"<p>You can also define your own scan parameters using a <code>.yaml</code> file. All supported parameters are demonstrated in:</p> <ul> <li><code>scan_configs/all_options_example.yaml</code></li> </ul> <p>Example:</p> <pre><code>min_rate: 1000\nports: \"22,80,443,3306\"\nscan_type: \"tcp\"\nmax_retries: 1\n</code></pre> <p>Run with:</p> <pre><code>./falcli.py fast-scan --config my_scan.yaml\n</code></pre> <p>This allows you to fine-tune each scan to your project needs or infrastructure quirks.</p>"},{"location":"use-cases/scan-configuration/#team-usage-and-preset-sharing","title":"Team Usage and Preset Sharing","text":"<p>Configuration files can be versioned and shared across teams to ensure consistent scanning policies. This improves:</p> <ul> <li>Repeatability across environments</li> <li>Auditability of scan logic</li> <li>Team alignment on port selection, rate limits, and strategy</li> </ul>"},{"location":"use-cases/team-collaboration/","title":"Real-Time Access and Collaboration on Scan Results","text":"<p>Falcoria enables real-time collaboration between multiple team members working on the same project. Once data is imported or a scan is launched, results become immediately available to all users connected to the shared backend \u2014 without needing to sync files, wait for exports, or coordinate tasks manually.</p>"},{"location":"use-cases/team-collaboration/#shared-workflow-example-external-scan-results","title":"Shared Workflow Example: External Scan Results","text":"<p>The following workflow demonstrates how one team member can import results from an external scan, and others can instantly explore, query, and export that data.</p>"},{"location":"use-cases/team-collaboration/#step-1-one-teammate-runs-an-external-scan","title":"Step 1 \u2014 One teammate runs an external scan","text":"<pre><code>nmap 134.209.203.62 -Pn -n -oX report.xml\n</code></pre> <p>Example scan output: <pre><code>PORT      STATE SERVICE\n22/tcp    open  ssh\n2222/tcp  open  EtherNetIP-1\n5432/tcp  open  postgresql\n50500/tcp open  unknown\n</code></pre></p> <p>Or start a scan with falcli. In this case you don't need to import results manually: <pre><code>./falcli.py scan start --hosts 134.209.203.62\n</code></pre></p>"},{"location":"use-cases/team-collaboration/#step-2-import-results-into-a-shared-project","title":"Step 2 \u2014 Import results into a shared project","text":"<pre><code>$ ./falcli.py project ips import -f report.xml\nImported IPs report into project '4e0d5a24-791d-4abb-a1fd-212f738b48b8'. Result: 1 IP.\n</code></pre>"},{"location":"use-cases/team-collaboration/#step-3-other-users-access-results-immediately","title":"Step 3 \u2014 Other users access results immediately","text":"<p>List all scanned IPs: <pre><code>$ ./falcli.py project ips list\nIP              PORT_COUNT\n134.209.203.62  4\n</code></pre></p> <p>Get full details for the host: <pre><code>$ ./falcli.py project ips get\nIP: 134.209.203.62\nStatus   : up\nOS       : -\nHostnames: -\n\nPORT   PROTO  STATE  SERVICE       BANNER\n22     tcp    open   ssh           -     \n2222   tcp    open   EtherNetIP-1  -     \n5432   tcp    open   postgresql    -     \n50500  tcp    open   -             -     \n</code></pre></p> <p>Download results as a report: <pre><code>$ ./falcli.py project ips download\n[+] Downloaded IPs report for project '4e0d5a24-791d-4abb-a1fd-212f738b48b8'.\n</code></pre></p>"},{"location":"use-cases/team-collaboration/#step-4-or-access-data-programmatically-via-api","title":"Step 4 \u2014 Or access data programmatically via API","text":"<p>Falcoria exposes a REST API to support integration into automation pipelines or external tools.</p> <pre><code>$ curl -s 'https://161.35.155.132/projects/4e0d5a24-791d-4abb-a1fd-212f738b48b8/ips' \\\n    -H 'Authorization: Bearer &lt;YOUR_AUTH_TOKEN&gt;' -k | jq\n</code></pre> <p>Example output: <pre><code>[\n  {\n    \"ip\": \"134.209.203.62\",\n    \"status\": \"up\",\n    \"ports\": [\n      { \"number\": 22, \"protocol\": \"tcp\", \"state\": \"open\", \"service\": \"ssh\" },\n      { \"number\": 2222, \"protocol\": \"tcp\", \"state\": \"open\", \"service\": \"EtherNetIP-1\" },\n      { \"number\": 5432, \"protocol\": \"tcp\", \"state\": \"open\", \"service\": \"postgresql\" },\n      { \"number\": 50500, \"protocol\": \"tcp\", \"state\": \"open\", \"service\": \"\" }\n    ]\n  }\n]\n</code></pre></p>"},{"location":"use-cases/team-collaboration/#summary","title":"Summary","text":"<ul> <li>One team member imports or launches a scan</li> <li>Others can immediately query results via CLI or API</li> <li>All data is centralized and synchronized via ScanLedger</li> </ul> <p>This real-time access eliminates delays, file syncing, and duplicated effort \u2014 enabling fast, coordinated recon and analysis across any size team.</p>"},{"location":"use-cases/update-enrichment/","title":"Update Enrichment","text":"<p>Use this mode when you want to enrich existing scan results with new data, such as additional ports, updated banners, or service info. The <code>update</code> mode does not delete existing data \u2014 it only adds or refreshes what\u2019s newly discovered.</p>"},{"location":"use-cases/update-enrichment/#command-example","title":"Command Example","text":"<pre><code>falcli scan start --config scan_configs/update_enrichment.yaml --targets-file targets.txt\n</code></pre>"},{"location":"use-cases/update-enrichment/#behavior","title":"Behavior","text":"<ul> <li>Keeps existing IPs and ports.</li> <li>Updates services, banners, and metadata if improved information is discovered.</li> <li>Adds new open ports that weren\u2019t previously present.</li> <li>Does not remove or overwrite existing data unless newer values are found.</li> </ul>"},{"location":"use-cases/update-enrichment/#use-case","title":"Use Case","text":"<p>You\u2019ve already scanned an infrastructure and now want to:</p> <ul> <li>Improve service detection with more aggressive settings</li> <li>Refresh outdated banner info</li> <li>Update open port set with additional targets or new exposure</li> </ul> <p>This is a safe mode to run multiple times without losing data.</p>"}]}
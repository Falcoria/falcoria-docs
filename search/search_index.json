{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"What is Falcoria","text":"<p>Falcoria is a scanning and coordination platform built for penetration testers and red teams. It automates host discovery, port scanning, and result consolidation across multiple systems, enabling structured and repeatable reconnaissance workflows at scale.</p>"},{"location":"#system-capabilities","title":"System Capabilities","text":""},{"location":"#parallelized-scan-execution","title":"Parallelized Scan Execution","text":"<p>Falcoria distributes scan tasks across independent worker nodes. As more nodes are added, scan time is reduced. This enables parallel scanning over large scopes while maintaining control over execution logic.</p>"},{"location":"#reliable-and-complete-scanning","title":"Reliable and Complete Scanning","text":"<p>Falcoria does not sacrifice accuracy for speed. Instead, it maintains a balance between performance and completeness. Its default configuration prioritizes reliable results without missing open ports or introducing false positives.</p>"},{"location":"#controlled-deduplication","title":"Controlled Deduplication","text":"<p>Falcoria applies deduplication at three levels:</p> <ol> <li> <p>User Input \u2013 Removes repeated targets from user-submitted input. Reduces noise and avoids unnecessary queue entries.</p> </li> <li> <p>Scan Execution \u2013 Skips targets already scanned or queued in the current project. Eliminates redundant scans and speeds up processing.</p> </li> <li> <p>Data Import \u2013 Uses Import Modes to merge or replace results. Preserves valid data and prevents duplication in storage.</p> </li> </ol> <p>This layered approach ensures targets are processed only once \u2014 unless explicitly redefined by the user.</p>"},{"location":"#stealth-via-port-sharding","title":"Stealth via Port Sharding","text":"<p>To reduce detection in monitored environments, Falcoria supports port sharding, distributing port ranges across workers. This minimizes scan signatures and allows phased recon under tighter controls.</p>"},{"location":"#configuration-driven-workflow","title":"Configuration-Driven Workflow","text":"<p>Scanning behavior is defined through YAML configuration files. These files are reusable, version-controlled, and portable between environments or teams.</p>"},{"location":"#api-native-interface","title":"API-Native Interface","text":"<p>All core actions \u2014 including project creation, scan execution, and result export \u2014 are accessible via documented HTTP APIs, enabling integration and automation.</p>"},{"location":"#why-falcoria","title":"Why Falcoria","text":"<p>Traditional recon workflows rely on scattered tools and manual scripting, often leading to untracked scans and inconsistent results. Falcoria consolidates scanning, state tracking, and data import into a single interface. It ensures that data is unique, results are preserved, and effort is not duplicated.</p>"},{"location":"#typical-setup","title":"Typical Setup","text":"<p>Falcoria is designed to run across multiple Linux-based nodes. A minimal deployment includes:</p> <ul> <li>1 server node running Redis, PostgreSQL, RabbitMQ, Scanledger, and Tasker</li> <li>1 or more worker nodes executing scans and pushing results</li> </ul> <p>Horizontal scaling is achieved by adding workers.</p>"},{"location":"#performance-snapshot","title":"Performance Snapshot","text":"<p>In the example below, 4 workers performed a full TCP scan across 4 IP addresses in approximately 7 seconds.</p> <p>This output demonstrates Falcoria\u2019s ability to scale horizontally and reduce total scan time through distributed execution.</p> <p></p>"},{"location":"architecture/","title":"Architecture Overview","text":"<p>Falcoria is a distributed scanning platform composed of modular services. Each part plays a specific role, ensuring scalable and consistent scanning across large infrastructure.</p>"},{"location":"architecture/#core-components","title":"Core Components","text":"<ul> <li> <p>CLI (falcli)   Command-line tool used to launch scans and retrieve results via API.</p> </li> <li> <p>Tasker (API)   Coordinates scan requests. Validates input, deduplicates targets, associates scans with a project, and queues scan tasks.</p> </li> <li> <p>Worker   Executes scan jobs using Nmap. Supports parallel execution and horizontal scaling.</p> </li> <li> <p>Scanledger (API)   Stores scan results per project. Provides endpoints for result retrieval, metadata access, and importing external scan data.</p> </li> <li> <p>Redis   Tracks runtime scan state and enforces deduplication during task preparation and execution.</p> </li> <li> <p>RabbitMQ   Message queue used to distribute scan tasks from Tasker to Workers.</p> </li> </ul>"},{"location":"architecture/#system-diagram","title":"System Diagram","text":"<pre><code>+--------+       +---------------+        +------------+        +-----------+\n| falcli | \u2500\u2500\u2500\u2500\u25ba |  Tasker (API) | \u2500\u2500\u2500\u2500\u2500\u25ba | RabbitMQ   | \u2500\u2500\u2500\u2500\u2500\u25ba |  Worker   |\n+--------+       +---------------+        +------------+        +-----------+\n      \u25b2                                                                |\n      \u2502                                                                |\n      \u2502                                                                \u25bc\n      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba+-------------------+\n                                                           | Scanledger (API)  |\n                                                           +-------------------+\n</code></pre>"},{"location":"architecture/#scan-workflow","title":"Scan Workflow","text":"<ol> <li>User runs <code>falcli</code> with a list of targets and optional scan configuration.</li> <li>CLI sends the request to Tasker via API.</li> <li>Tasker validates input, assigns or uses an existing project ID, applies deduplication, and prepares the scan job.</li> <li>Tasker sends the job to the RabbitMQ queue.</li> <li>A Worker receives the task and executes the scan using Nmap.</li> <li>Worker sends scan results to Scanledger.</li> <li>User retrieves results from Scanledger using <code>falcli</code>.</li> </ol>"},{"location":"architecture/#scalability","title":"Scalability","text":"<ul> <li>Workers can be added or removed independently.</li> <li>Each Worker processes tasks in parallel.</li> <li>There is no hard limit on the number of Workers in the system.</li> </ul>"},{"location":"architecture/#extensibility","title":"Extensibility","text":"<p>Falcoria is designed with modularity and chaining in mind. Future extensions may include:</p> <ul> <li>Tool chaining (e.g., Nmap \u2192 Nuclei)</li> <li>Customizable workflows and conditional task execution</li> <li>Configurable scan templates with predefined logic</li> </ul>"},{"location":"import-modes/","title":"Import Modes in Falcoria","text":"<p>Falcoria supports four import modes to give you full control over how scan results are added and updated within a project. These modes help prevent duplication, ensure consistency, and support workflows like incremental enrichment or full rescan replacement.</p>"},{"location":"import-modes/#summary-table","title":"Summary Table","text":"Mode Behavior Primary Use Case insert Adds new entries; skips duplicates Safe initial loads and clean data imports replace Replaces all existing records entirely Full target rescan or authoritative result refresh append Adds new data without touching existing records Port sharding, parallel scans, multi-phase collection update Updates only specific fields, preserves all others Incremental enrichment, banner or service info refinement"},{"location":"import-modes/#insert-mode","title":"<code>insert</code> Mode","text":"<p>Adds new data only if the IP does not already exist in the project. If the IP is already present, it will be skipped silently.</p> <p>Best for:</p> <ul> <li>Initial imports</li> <li>Non-destructive runs</li> <li>Loading many partial reports</li> </ul> <p>Example:</p> <pre><code>$ python3 falcli.py project ips import --file report_insert1.xml --mode insert\nImported IPs report into project '5a2e5a0d-a36f-456f-822d-4769c4e0fd4f'. Result: 2 IPs.\n\n$ python3 falcli.py project ips list\nIP              PORT_COUNT\n134.209.203.62  6         \n159.223.15.22   6         \n\n$ python3 falcli.py project ips import --file report_insert2.xml --mode insert\nImported IPs report into project '5a2e5a0d-a36f-456f-822d-4769c4e0fd4f'. Result: 1 IP.\n\n$ python3 falcli.py project ips list\nIP               PORT_COUNT\n134.209.203.62   6         \n159.223.15.22    6         \n188.166.121.245  8         \n</code></pre>"},{"location":"import-modes/#append-mode","title":"<code>append</code> Mode","text":"<p>Adds new data regardless of duplicates. Existing records are not touched or merged.</p> <p>Best for:</p> <ul> <li>Combining multiple scans</li> <li>Port sharding</li> <li>Merging safe/partial and extended scans</li> </ul> <p>Example:</p> <pre><code>$ python3 falcli.py project ips import --file report_append1.xml \nImported IPs report into project '5a2e5a0d-a36f-456f-822d-4769c4e0fd4f'. Result: 1 IP.\n\n$ python3 falcli.py project ips get\nIP: 134.209.203.62\nStatus   : up\nOS       : -\nHostnames: -\n\nPORT  PROTO  STATE  SERVICE       BANNER\n22    tcp    open   ssh           -     \n2222  tcp    open   EtherNetIP-1  -     \n5432  tcp    open   postgresql    -     \n\n$ python3 falcli.py project ips import --file report_append2.xml --mode append\nImported IPs report into project '5a2e5a0d-a36f-456f-822d-4769c4e0fd4f'. Result: 1 IP.\n\n$ python3 falcli.py project ips get\nIP: 134.209.203.62\nStatus   : up\nOS       : -\nHostnames: -\n\nPORT   PROTO  STATE  SERVICE       BANNER                                                                     \n22     tcp    open   ssh           -                                                                          \n2222   tcp    open   EtherNetIP-1  -                                                                          \n5432   tcp    open   postgresql    -                                                                          \n6379   tcp    open   redis         product: Redis key-value store                                             \n50500  tcp    open   http          product: Golang net/http server extrainfo: Go-IPFS json-rpc or InfluxDB API\n</code></pre>"},{"location":"import-modes/#replace-mode","title":"<code>replace</code> Mode","text":"<p>Completely overwrites all existing data for an IP, including all ports. Even matching ports are replaced.</p> <p>Best for:</p> <ul> <li>Retesting</li> <li>Overwriting old scan results</li> </ul> <p>Example:</p> <pre><code>$ python3 falcli.py project ips import --file report_replace1.xml\nImported IPs report into project '5a2e5a0d-a36f-456f-822d-4769c4e0fd4f'. Result: 1 IP.\n\n$ python3 falcli.py project ips get\nIP: 134.209.203.62\nStatus   : up\nOS       : -\nHostnames: -\n\nPORT  PROTO  STATE  SERVICE  BANNER                                                                                                 \n22    tcp    open   ssh      product: OpenSSH version: 8.9p1 Ubuntu 3ubuntu0.13 extrainfo: Ubuntu Linux; protocol 2.0 ostype: Linux\n\n$ python3 falcli.py project ips import --file report_replace2.xml --mode replace\nImported IPs report into project '5a2e5a0d-a36f-456f-822d-4769c4e0fd4f'. Result: 1 IP.\n\n$ python3 falcli.py project ips get\nIP: 134.209.203.62\nStatus   : up\nOS       : -\nHostnames: -\n\nPORT  PROTO  STATE  SERVICE     BANNER\n22    tcp    open   ssh         -     \n5432  tcp    open   postgresql  -     \n</code></pre>"},{"location":"import-modes/#update-mode","title":"<code>update</code> Mode","text":"<p>Performs a smart merge. Keeps existing ports and only updates fields that are explicitly present in the new report. Values like <code>banner</code> or <code>service</code> are preserved unless overwritten.</p> <p>Best for:</p> <ul> <li>Incremental enrichment</li> <li>Deepening banner/service info</li> </ul> <p>Example:</p> <pre><code>$ python3 falcli.py project ips import --file report_update1.xml\nImported IPs report into project '5a2e5a0d-a36f-456f-822d-4769c4e0fd4f'. Result: 1 IP.\n\n$ python3 falcli.py project ips get\nIP: 134.209.203.62\nStatus   : up\nOS       : -\nHostnames: -\n\nPORT  PROTO  STATE  SERVICE       BANNER\n22    tcp    open   ssh           -     \n2222  tcp    open   EtherNetIP-1  -     \n5432  tcp    open   postgresql    -     \n\n$ python3 falcli.py project ips import --file report_update2.xml --mode update\nImported IPs report into project '5a2e5a0d-a36f-456f-822d-4769c4e0fd4f'. Result: 1 IP.\n\n$ python3 falcli.py project ips get\nIP: 134.209.203.62\nStatus   : up\nOS       : -\nHostnames: -\n\nPORT   PROTO  STATE  SERVICE     BANNER                                                                                                 \n22     tcp    open   ssh         product: OpenSSH version: 8.9p1 Ubuntu 3ubuntu0.13 extrainfo: Ubuntu Linux; protocol 2.0 ostype: Linux\n2222   tcp    open   ssh         product: OpenSSH version: 9.9 extrainfo: protocol 2.0                                                 \n5432   tcp    open   postgresql  product: PostgreSQL DB version: 9.6.0 or later                                                        \n6379   tcp    open   redis       product: Redis key-value store                                                                        \n50500  tcp    open   http        product: Golang net/http server extrainfo: Go-IPFS json-rpc or InfluxDB API                           \n</code></pre> <p>Note: All modes will add new IP addresses that don't already exist in the project. For scans insert mode is default.</p>"},{"location":"import-modes/#field-level-behavior","title":"Field-Level Behavior","text":"Mode IP Address Ports Service Info Summary Use Case insert Creates new Creates new Creates new First-time scan, safe inserts only replace Overwrites Fully replaces Fully replaces Rescan or full refresh append Adds if new Adds only new ports Does not change existing fields Port sharding, safe parallel merge update Keeps existing Keeps existing Updates provided fields only Service enrichment, field-by-field enhancement <p>Use these modes to control how data enters Falcoria and to design scanning workflows that match your infrastructure and goals.</p>"},{"location":"installation/","title":"Installation","text":"<p>Falcoria CLI is the command-line interface for configuring and managing  distributed scans through the Falcoria platform. This guide covers  installation and setup of the CLI tool only.</p> <p>Note: The CLI requires a running Falcoria backend (Scanledger, Tasker, Redis, RabbitMQ). This guide does not include backend deployment steps.</p>"},{"location":"installation/#requirements","title":"Requirements","text":"<ul> <li>Python 3.8 or higher</li> <li>Git</li> <li>Linux or macOS (Windows is supported via WSL or Python virtualenv)</li> </ul>"},{"location":"installation/#step-by-step-setup","title":"Step-by-Step Setup","text":"<pre><code># 1. Clone the repository\ngit clone https://github.com/Falcoria/falcli.git\ncd falcli\n\n# 2. Create and activate a virtual environment\npython3 -m venv venv\nsource venv/bin/activate  # On Windows: venv\\Scripts\\activate\n\n# 3. Install dependencies\npip install -r requirements.txt\n\n# 4. Verify installation\npython3 falcli.py\n</code></pre>"},{"location":"installation/#cli-help-preview","title":"CLI Help Preview","text":"<pre><code>Usage: falcli.py [OPTIONS] COMMAND [ARGS]...\n\nOptions:\n  --version, -v             Show the version and exit.\n  --install-completion      Install shell completion.\n  --show-completion         Show shell completion info.\n  --help                    Show this message and exit.\n\nCommands:\n  fast-scan   Start a quick scan, track it, and download report\n  project     Manage projects and IP data.\n  config      Configure CLI settings and backend URLs.\n  memory      View or clear stored memory state.\n  scan        Start, stop, or preview scans.\n  workers     Manage worker nodes and their IPs.\n</code></pre>"},{"location":"quick-start/","title":"Quick Start","text":"<p>This guide provides two streamlined ways to get started with Falcoria: a high-level automatic workflow using <code>fast-scan</code>, and a more manual, step-by-step process for full control.</p>"},{"location":"quick-start/#option-1-fast-path-with-fast-scan","title":"Option 1: Fast Path with <code>fast-scan</code>","text":"<p>Use this when you want to scan quickly with minimal setup.</p> <pre><code>falcli fast-scan --config scan_configs/default.yaml --hosts 192.168.1.1,192.168.1.2\n</code></pre> <p>This command will:</p> <ul> <li>Create a new project with a random name</li> <li>Send a scan request to Tasker</li> <li>Track progress until completion</li> <li>Show scanned IPs and port summary</li> <li>Save report locally (XML by default)</li> </ul> <p>You can also pass <code>--delete</code> if you want to remove the project after report download.</p>"},{"location":"quick-start/#option-2-manual-step-by-step-control","title":"Option 2: Manual Step-by-Step Control","text":"<p>Use this when you want explicit control over project creation, task sending, and data download.</p>"},{"location":"quick-start/#1-create-project","title":"1. Create Project","text":"<pre><code>falcli project create --name internal-net\n</code></pre>"},{"location":"quick-start/#2-start-scan","title":"2. Start Scan","text":"<pre><code>falcli project scan start --config scan_configs/custom.yaml --hosts 192.168.1.1,192.168.1.2\n</code></pre>"},{"location":"quick-start/#3-check-scan-status","title":"3. Check Scan Status","text":"<pre><code>falcli project scan status\n</code></pre>"},{"location":"quick-start/#4-get-scanned-ips","title":"4. Get Scanned IPs","text":"<pre><code>falcli project ips list\n</code></pre>"},{"location":"quick-start/#5-download-report","title":"5. Download Report","text":"<pre><code>falcli project ips download\n</code></pre> <p>This manual workflow gives you full control over scope, mode, configuration, and report handling.</p> <p>You can switch between both approaches depending on your use case \u2014 speed and simplicity vs. precision and flexibility.</p>"},{"location":"use-cases/","title":"Falcoria Use Cases","text":"<p>Falcoria supports a wide range of real-world workflows through two primary categories:</p> <ul> <li>Scan Strategies \u2013 how scans are executed</li> <li>Report Handling \u2013 how scan results are imported, enriched, or merged</li> </ul> <p>This document outlines the most essential use cases for the MVP release.</p>"},{"location":"use-cases/#1-scan-strategies","title":"1. Scan Strategies","text":""},{"location":"use-cases/#port-sharding-across-workers","title":"Port Sharding Across Workers","text":"<p>Distribute port ranges across multiple workers to parallelize scans and reduce detection by IDS/IPS.</p> <pre><code>falcli fast-scan --config ports_0-10000.yaml --hosts targets.txt\nfalcli fast-scan --config ports_10001-65535.yaml --hosts targets.txt\n</code></pre> <p>Import Mode: <code>append</code></p> <p>\u26a0\ufe0f To ensure optimal task distribution, launch the scans one by one with short delays between commands. This gives workers time to claim tasks without conflicts.</p>"},{"location":"use-cases/#fast-scan-only-no-service-detection","title":"Fast Scan Only (No Service Detection)","text":"<p>Run a lightweight scan to detect open ports quickly, skipping service detection entirely.</p> <p>Why This Matters:</p> <ul> <li>Speeds up scanning time, especially for large scopes</li> <li>Minimizes noise to avoid detection by firewalls, IDS, and honeypots</li> <li>Allows chaining with external tools for post-processing</li> </ul> <pre><code>falcli fast-scan --config fast_ports.yaml --hosts targets.txt\n</code></pre>"},{"location":"use-cases/#service-detection-behavior-default-and-optional","title":"Service Detection Behavior (Default and Optional)","text":"<p>By default, Falcoria first discovers open ports and then performs service detection for those ports.</p> <ul> <li>You can disable service detection in the configuration file to run only the discovery phase.</li> <li>Falcoria saves open ports found during the first phase.</li> <li>If some ports are later closed (e.g., by firewall rules) during service detection, they will still be retained in the project.</li> </ul>"},{"location":"use-cases/#offline-project-imports","title":"Offline Project Imports","text":"<p>Useful for air-gapped or internal environments where scan results are collected manually.</p> <p>Why This Matters:</p> <ul> <li>Supports internal pentests or red team ops without internet access</li> <li>Integrates legacy tool output (e.g., Nmap XML)</li> <li>Still benefits from Falcoria\u2019s deduplication and import logic</li> </ul> <pre><code>falcli project ips import --file scan.xml --mode insert\n</code></pre>"},{"location":"use-cases/#2-report-handling","title":"2. Report Handling","text":""},{"location":"use-cases/#enrich-partial-results","title":"Enrich Partial Results","text":"<p>First import open ports only, then later import banners or services to update only changed fields.</p> <pre><code>falcli project ips import --file service_scan.xml --mode update\n</code></pre> <p>Import Mode: <code>update</code></p>"},{"location":"use-cases/#replace-changed-hosts","title":"Replace Changed Hosts","text":"<p>If a rescan reveals different open ports, fully replace the corresponding host\u2019s data.</p> <p>Why This Matters:</p> <ul> <li>During long engagements, the network state may change frequently</li> <li>Ensures the scan data stays fresh and relevant</li> <li>Eliminates outdated results without manual cleanup</li> </ul> <pre><code>falcli project ips import --file latest_scan.xml --mode replace\n</code></pre> <p>Import Mode: <code>replace</code></p>"},{"location":"use-cases/#initial-import-and-deduplication","title":"Initial Import and Deduplication","text":"<p>Safely load scan results into a project. Whether importing manually or via workers, the backend ensures that no duplicate IP-port pairs are stored. This avoids redundancy when multiple team members scan the same targets.</p> <p>Why This Matters:</p> <ul> <li>Reduces storage overhead</li> <li>Ensures clean project history</li> <li>Prevents conflicts in collaborative workflows</li> </ul> <pre><code>falcli fast-scan --hosts team1.txt --mode insert\nfalcli project ips import --file external_team_scan.xml --mode insert\n</code></pre> <p>Import Mode: <code>insert</code> or <code>update</code></p> <p>These core use cases define the MVP-level capabilities of Falcoria. They ensure efficient scanning, parallel execution, clean data management, and reliable collaboration.</p>"},{"location":"what-is-falcoria/","title":"Introduction to Falcoria","text":"<p>Falcoria is a distributed scanning and coordination platform built for penetration testers and red teams. It automates host discovery, port scanning, and result collection across multiple machines, enabling efficient recon at scale while avoiding duplicated effort.</p>"},{"location":"what-is-falcoria/#core-advantages","title":"Core Advantages","text":""},{"location":"what-is-falcoria/#speed-through-distributed-scanning","title":"Speed Through Distributed Scanning","text":"<p>Falcoria distributes scans across unlimited workers. Add 10 workers \u2014 it runs \\~10\u00d7 faster. Scaling is horizontal, not capped.</p>"},{"location":"what-is-falcoria/#high-accuracy-by-design","title":"High Accuracy by Design","text":"<p>Falcoria performs full scans with full output \u2014 no missed ports, no lost banners. Unlike superficial scanners, it never sacrifices detail for speed.</p>"},{"location":"what-is-falcoria/#no-duplication-runtime-and-storage-level","title":"No Duplication \u2014 Runtime and Storage-Level","text":"<p>Falcoria prevents accidental rescans and duplicate results through Redis locks and import modes. You won\u2019t scan the same IP twice \u2014 or store it twice.</p>"},{"location":"what-is-falcoria/#evasion-capabilities-port-sharding","title":"Evasion Capabilities \u2014 Port Sharding","text":"<p>Falcoria supports port sharding, allowing you to split port scans across workers. This reduces noise and helps evade detection in monitored environments.</p>"},{"location":"what-is-falcoria/#cli-first-declarative-scanning","title":"CLI-First &amp; Declarative Scanning","text":"<p>Falcoria is built around a CLI-first workflow. Scan configurations are defined in clean YAML files \u2014 easy to version, reuse, and share. This brings clarity and control to your recon \u2014 without relying on GUIs or brittle shell scripts.</p>"},{"location":"what-is-falcoria/#api-native-by-design","title":"API-Native by Design","text":"<p>Everything in Falcoria is powered by documented APIs. You can automate every step \u2014 from project creation to scan execution and result download \u2014 or seamlessly integrate Falcoria into your own systems.</p>"},{"location":"what-is-falcoria/#why-falcoria-exists","title":"Why Falcoria Exists","text":"<p>Falcoria was built to fix the broken state of recon workflows: untracked scans, duplicated effort, and incomplete results. We wanted a scanner that\u2019s fast, reliable, automatable \u2014 and actually scales.</p>"}]}
{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"What is Falcoria","text":"<p>Falcoria is a system for team-based network scanning for large and dynamic scopes. Each scan run updates a shared map of hosts, ports, and services used by the entire team.</p> <p>Falcoria centralizes network scanning work and keeps scan results in one shared place. Each new scan updates existing data instead of creating isolated output files.</p> <p>It addresses two practical problems:</p> <ul> <li>scan execution speed,</li> <li>consistency and sharing of scan results across the team.</li> </ul> <p>This is handled by two main parts:</p> <ul> <li>Scan execution \u2014 runs scans and collects data  </li> <li>Data aggregation \u2014 merges scan results into a single shared view  </li> </ul> <p></p>"},{"location":"#scan-execution","title":"Scan Execution","text":"<p>Scan execution runs scans and produces scan data. It is designed to be fast, reliable, and to avoid unnecessary network load.</p>"},{"location":"#scan-execution-mechanisms","title":"Scan Execution mechanisms","text":"<ul> <li> <p>Distributed scanning   Scan tasks can be executed across multiple workers.   This allows scans to finish earlier by spreading work across different machines.   \u2192 Learn more about distribution</p> </li> <li> <p>Target deduplication   Duplicate targets are removed before scanning starts.   The same IP address, hostname, or subnet is not scanned more than once unintentionally.   This reduces unnecessary network load and lowers the risk of triggering rate limits.   \u2192 Learn more about deduplication</p> </li> <li> <p>Optimized scan configurations   Predefined scan configurations are used to run scans with consistent and tested settings.   These configs provide a balance between speed and coverage.   \u2192 Learn more about scan configs</p> </li> </ul> <p>\u2192 Benchmarks</p>"},{"location":"#data-aggregation","title":"Data Aggregation","text":"<p>Data aggregation is responsible for combining scan results into one shared view of the network. Each new scan updates the existing dataset rather than producing a separate report.</p> <p>This ensures that the team always works with a single, up-to-date set of hosts, ports, and services, even when scans are repeated, extended, or run by different people.</p>"},{"location":"#data-aggregation-mechanisms","title":"Data Aggregation mechanisms","text":"<ul> <li> <p>State-based data model   All scan data is stored as a single set of unique records.   Entries are updated automatically, so the entire team works with the same current view.</p> </li> <li> <p>Incremental updates   Scan results are applied incrementally to the shared dataset.   New data extends or updates existing records without affecting unrelated entries.   For example, scanning additional ports on known hosts adds only the new ports,   while previously collected data remains unchanged.   \u2192 Learn more about Import Modes</p> </li> <li> <p>Focused change log   Tracks only actual changes in port state, service, or banner.   Each entry shows the previous and new value for a single change.   Full scan output and unchanged ports are excluded.   \u2192 Learn more about Track History</p> </li> <li> <p>API and export access   Aggregated scan data is available via an API and standardized export formats, including Nmap XML and JSON.   This allows teams to retrieve a unified network view and integrate it into existing tools, automation, and reporting pipelines.</p> </li> <li> <p>CLI-based data exploration   Scan data can be explored using a dedicated CLI, providing structured output and controlled navigation through large result sets.</p> </li> </ul>"},{"location":"#who-its-for","title":"Who It's For","text":"<ul> <li>Penetration testers working with large or frequently changing scopes</li> <li>Red team operators performing repeated network discovery</li> <li>Security engineers maintaining a current view of exposed hosts, ports, and services</li> </ul>"},{"location":"#get-started","title":"Get Started","text":"<p>To understand how Falcoria is used in practice, start here: Common Workflow \u2014 Step-by-Step Example</p> <ul> <li>Installation Guide </li> <li>Import Modes</li> <li>Architecture Overview </li> </ul>"},{"location":"architecture/","title":"Architecture","text":"<p>Falcoria is built around two main components:</p> <ul> <li>Scan Execution</li> <li>Data Aggregation</li> </ul> <p>They are implemented as separate API services. Scan execution and data aggregation communicate only through API calls.</p> <p></p>"},{"location":"architecture/#core-components","title":"Core Components","text":""},{"location":"architecture/#scan-execution","title":"Scan Execution","text":"<p>Scan Execution is responsible for running scans.</p> <p>Its role is to prepare scan tasks, execute them, and deliver raw results for aggregation.</p> <p>Scan Execution consists of three parts:</p> <ul> <li>Tasker</li> <li>Queue</li> <li>Workers</li> </ul> <p>Tasker accepts scan requests (via API or <code>falcli</code>), performs target preparation, and applies target deduplication before execution. Duplicate IPs, hostnames, and subnets are removed at this stage.  </p> <p>Each execution task targets:</p> <ul> <li>a single IP address,</li> <li>a defined set of ports,</li> <li>associated hostnames (kept as metadata).</li> </ul> <p>Prepared tasks are published to the Queue.</p> <p>Queue stores execution tasks until they are picked up by workers.</p> <p>Workers consume tasks from the queue and execute scans. Each worker runs on its own machine or network environment and uses its own network path to the target.</p> <p>This is critical for Distribution: workers must have independent network paths for parallel execution to be effective.  </p> <p>Scan Execution scales by adding workers.</p>"},{"location":"architecture/#data-aggregation","title":"Data Aggregation","text":"<p>Data Aggregation is responsible for maintaining the shared scan dataset.</p> <p>It receives scan results from workers and applies them to a single shared state used by the entire team.</p> <p>Data Aggregation consists of one core component:</p> <ul> <li>ScanLedger</li> </ul> <p>ScanLedger stores scan data as a shared dataset with unique records. New results update existing entries or extend them, rather than creating duplicates.</p> <p>All logic related to:</p> <ul> <li>incremental updates,</li> <li>partial updates,</li> <li>replacement of scanned data,</li> <li>and change tracking</li> </ul> <p>is handled inside ScanLedger.</p> <p>\u2192 See:</p> <ul> <li>Import Modes</li> <li>History Tracking</li> </ul> <p>ScanLedger is the single source of truth for hosts, IPs, ports, services, and their change history.</p>"},{"location":"architecture/#scan-flow","title":"Scan Flow","text":"<ol> <li>A scan request is sent via falcli or API.</li> <li>The request reaches Tasker.</li> <li>Tasker applies deduplication and prepares execution tasks.</li> <li>Tasks are published to the Queue.</li> <li>Workers pull tasks and execute scans.</li> <li>Scan results are sent to ScanLedger.</li> <li>ScanLedger merges results into the shared dataset.</li> <li>Users retrieve data from ScanLedger via API or <code>falcli</code>.</li> </ol>"},{"location":"architecture/#key-properties","title":"Key Properties","text":"<ul> <li>Scan execution and data aggregation are cleanly separated.</li> <li>Execution scales by adding workers with independent network paths.</li> <li>All scan data is merged into one shared dataset.</li> <li>Partial rescans and incremental updates do not break existing data.</li> <li>The entire team always works with the same current view.</li> </ul>"},{"location":"benchmarks/","title":"Benchmarks","text":"<p>This page summarizes measured scan performance results used by Falcoria.</p> <p>Detailed methodology, raw data, and test scripts are documented separately in the research article: \u2192 Nmap vs Masscan vs Rustscan: Myths and Facts (Medium)</p>"},{"location":"benchmarks/#summary","title":"Summary","text":"<p>The tests focus on open port discovery under realistic conditions:</p> <ul> <li>hundreds to thousands of targets</li> <li>stable and unstable networks</li> <li>accuracy \u2265 99%</li> </ul> <p>The key finding is that architecture and network placement matter more than the scanner itself.</p>"},{"location":"benchmarks/#time-to-scan-1000-targets","title":"Time to Scan 1,000 Targets","text":"<p>Estimated scan time for 1,000 hosts using stable configurations:</p> Setup Time Nmap (home, default) 32h 16m Nmap (home, tuned) 4h 56m Nmap (cloud \u2192 cloud) 1h 12m Distributed (4 nodes) 22m 25s Distributed (10 nodes) 8m 58s"},{"location":"benchmarks/#key-observations","title":"Key Observations","text":"<ul> <li>Single-host scans hit network limits quickly.</li> <li>Parallel scans on one machine do not provide meaningful gains.</li> <li>Placing scanners in the same cloud as targets improves speed by ~30%.</li> <li>Distributed scanning scales close to linearly until target-side limits are reached.</li> </ul>"},{"location":"benchmarks/#why-this-matters-for-falcoria","title":"Why This Matters for Falcoria","text":"<p>Falcoria is designed around these constraints:</p> <ul> <li>Distributed execution across independent network paths.</li> <li>Reliable scan configurations instead of aggressive rates.</li> <li>Central aggregation of results into a single shared state.</li> </ul> <p>Benchmarks are used to validate these design decisions, not to compare tools in isolation.</p>"},{"location":"benchmarks/#references","title":"References","text":"<ul> <li>Full research article (methodology and raw data)</li> <li>Cloud-to-cloud benchmarks</li> <li>Home-to-cloud benchmarks</li> <li>Distributed scan benchmarks</li> <li>Extrapolation scripts</li> </ul>"},{"location":"quick-start/","title":"Quick Start","text":"<p>This guide provides a manual, step-by-step process for full control when getting started with Falcoria.</p> <p>\u2699\ufe0f This guide uses <code>falcli</code> \u2014 Falcoria's command-line interface. Make sure it\u2019s installed and connected to a running backend before proceeding.</p>"},{"location":"quick-start/#manual-step-by-step-control","title":"Manual Step-by-Step Control","text":"<p>Use this when you want explicit control over project creation, task sending, and data download.</p>"},{"location":"quick-start/#1-create-project","title":"1. Create Project","text":"<pre><code>falcli project create --name internal-net\n</code></pre>"},{"location":"quick-start/#2-start-scan","title":"2. Start Scan","text":"<pre><code>falcli project scan start --config scan_configs/custom.yaml --hosts example.com,scanme.nmap.org\n</code></pre>"},{"location":"quick-start/#3-check-scan-status","title":"3. Check Scan Status","text":"<pre><code>falcli project scan status\n</code></pre>"},{"location":"quick-start/#4-get-scanned-ips","title":"4. Get Scanned IPs","text":"<pre><code>falcli project ips get\n</code></pre>"},{"location":"quick-start/#5-download-report","title":"5. Download Report","text":"<pre><code>falcli project ips download\n</code></pre> <p>This manual workflow gives you full control over scope, mode, configuration, and report handling.</p>"},{"location":"concepts/","title":"Concepts","text":"<p>This section explains the key mechanisms that define how Falcoria works. They are not optional features, but the foundation that makes it different from traditional scanning tools.</p>"},{"location":"concepts/#what-concepts-cover","title":"What Concepts Cover","text":"<ul> <li>Deduplication: Prevents duplicate scans and tasks, saving time and resources.  </li> <li>Distribution: Enables fast, parallel scanning by splitting work across multiple workers.  </li> <li>History Tracking: Records changes between scans, so teams can focus on what matters.  </li> <li>Import Modes: Controls how new data is merged, updated, or replaced in the system.  </li> <li>Scan Configurations: Defines how scans are performed using YAML files for flexible, repeatable scanning strategies.</li> </ul> <p>Together, these concepts address the main challenges of large and changing scopes.</p>"},{"location":"concepts/configs/","title":"Configs","text":"<p>In Falcoria, a config defines how a scan is executed.</p> <p>A config is a YAML file that describes scan behavior, such as:</p> <ul> <li>which ports are scanned,</li> <li>which protocols or services are included,</li> <li>how scan results are processed.</li> </ul> <p>Targets and scan behavior are defined separately:</p> <ul> <li>targets define what is scanned,</li> <li>configs define how it is scanned.</li> </ul>"},{"location":"concepts/configs/#built-in-scan-profiles","title":"Built-in Scan Profiles","text":"<p>Falcoria provides predefined configs for common scan tasks.</p> <p>Examples include:</p> <ul> <li>HTTP-only scans,</li> <li>full port range scans,</li> <li>UDP scans,</li> <li>scans that detect only open ports,</li> <li>scans that include service and banner detection.</li> </ul> <p>These configs allow scans to be started without manual parameter selection.</p>"},{"location":"concepts/configs/#sharing-and-reuse","title":"Sharing and Reuse","text":"<p>Configs are reusable and portable.</p> <p>A config can be:</p> <ul> <li>reused across multiple projects,</li> <li>shared between team members,</li> <li>stored as part of a project setup.</li> </ul> <p>This helps teams keep scan behavior consistent and reduces repeated configuration work.</p>"},{"location":"concepts/configs/#embedded-experience","title":"Embedded Experience","text":"<p>Configs are based on tested scan setups and practical usage.</p> <p>They reflect known trade-offs between speed, coverage, and reliability. Using a config applies these settings directly, without manual tuning.</p>"},{"location":"concepts/configs/#practical-usage","title":"Practical Usage","text":"<p>Configs support staged scanning.</p> <p>A typical workflow includes:</p> <ul> <li>starting with a lightweight scan,</li> <li>expanding to broader scans,</li> <li>refreshing selected parts of the scope.</li> </ul> <p>Targets remain the same, while configs control scan depth and behavior.</p>"},{"location":"concepts/deduplication/","title":"Deduplication Behavior","text":"<p>Falcoria applies deduplication at several stages of the workflow. This prevents redundant work, reduces scan time, avoids unnecessary tasks, and lowers the likelihood of hitting rate limits.</p> <p>Deduplication: </p> <ul> <li>String duplicates in input files </li> <li>Unification of subnets and hostnames </li> <li>Skipping already stored targets (ScanLedger) </li> <li>Skipping duplicate tasks in the queue</li> </ul>"},{"location":"concepts/deduplication/#string-duplicates-in-input-files","title":"String duplicates in input files","text":"<p>When a user provides a list of targets, duplicate string entries are removed. If the same hostname or IP address appears multiple times, only one entry is kept.</p>"},{"location":"concepts/deduplication/#unification-of-subnets-and-hostnames","title":"Unification of subnets and hostnames","text":"<p>Falcoria normalizes mixed input before creating scan tasks:  </p> <ul> <li>Subnets (CIDR) are expanded into full lists of IP addresses.  </li> <li>Hostnames are resolved to IP addresses.  </li> <li>The final dataset contains only unique IPs and the hostnames associated with them.  </li> </ul> <p>This ensures each address is scanned only once. It also shortens scan time and lowers the chance of triggering blocking mechanisms.  </p> <p>Image placeholder: show subnet expansion and hostname resolution \u2192 resulting unique IP/hostname map.  </p>"},{"location":"concepts/deduplication/#skipping-already-stored-targets-scanledger","title":"Skipping already stored targets (ScanLedger)","text":"<p>If a target already exists in ScanLedger, it is not scanned again.</p> <p>This applies to:</p> <ul> <li>new scan launches,</li> <li>imported scan results.</li> </ul> <p>By default, this behavior is active in Insert mode. For details about other modes, see Import Modes.  </p> <p>Image placeholder: show ScanLedger with already stored IPs \u2192 new incoming data skipped.  </p>"},{"location":"concepts/deduplication/#skipping-duplicate-tasks-in-the-queue","title":"Skipping duplicate tasks in the queue","text":"<p>If an identical scan task is already queued, a new task is not created. This prevents multiple users or processes from scanning the same target at the same time.</p> <p>Image placeholder: show queue with existing tasks \u2192 duplicate request rejected.  </p>"},{"location":"concepts/distribution/","title":"Distribution","text":"<p>Distribution is the execution of scan tasks across multiple parallel workers in Falcoria. It increases available throughput and reduces total scan time.</p> <p></p>"},{"location":"concepts/distribution/#when-distribution-is-needed","title":"When Distribution Is Needed","text":"<p>Faster scans are important usually in two cases:</p> <ul> <li> <p>Large scopes   Faster execution allows teams to start analysis and follow-up tasks earlier.</p> </li> <li> <p>Dynamic scopes   When a scope changes frequently, faster scans make it possible to rescan the entire scope often enough to track changes.</p> </li> </ul> <p>Measured behavior and scaling limits are described in the performance article. Performance Benchmarks</p>"},{"location":"concepts/distribution/#behavior","title":"Behavior","text":"<ul> <li>Scan tasks are distributed across available workers.</li> <li>Adding workers can reduce total scan time.</li> <li>Throughput increases until limited by network bottlenecks or target capacity.</li> </ul> <p>Observed scaling behavior is discussed in the performance article. Performance Benchmarks</p>"},{"location":"concepts/track-history/","title":"History Tracking","text":"<p>In Falcoria, history tracking records changes to port state, service, and banner data as scan results update the shared network state.</p> <p></p>"},{"location":"concepts/track-history/#what-is-recorded","title":"What Is Recorded","text":"<p>A history entry is created for a port when one of its attributes changes:</p> <ul> <li>Port State \u2014 for example, from <code>open</code> to <code>closed</code>.</li> <li>Service \u2014 the detected service on the port.</li> <li>Banner \u2014 application banner or version string.</li> </ul> <p>History is recorded only for attributes that were re-scanned and changed. Ports that were not included in a scan retain their previous state.</p>"},{"location":"concepts/track-history/#how-it-works","title":"How It Works","text":"<p>When scan results are imported, they are compared against the existing network state stored in ScanLedger.</p> <p>For scanned targets, detected changes are written to the history log with a timestamp. Ports and services that were not part of the scan remain unchanged.</p> <p>The history log is available through the API and the <code>falcli</code> command-line client.</p>"},{"location":"concepts/track-history/#why-this-matters","title":"Why This Matters","text":"<ul> <li>On large scopes with many IPs and ports, rescans can produce large result sets.</li> <li>History shows only what changed between scans.</li> <li>This makes follow-up checks faster and reduces the risk of missing important changes.</li> </ul>"},{"location":"concepts/import-modes/","title":"Import modes","text":"<p>Managing scan results as separate files leads to fragmented and unclear network views. On large, evolving scopes, scans are often partial, repeated, or use varied techniques, making manual tracking impractical.</p> <p>Falcoria maintains a shared network state that represents all known hosts, ports, and services. This approach, referred to as Data Aggregation, allows scan results to be accumulated into a single, consistent view. The shared state is stored and maintained by ScanLedger.</p> <p>Import modes define how incoming scan reports update this shared state. They control how new data is applied to existing IPs and ports.</p> <p>Falcoria provides four import modes: INSERT, APPEND, UPDATE, and REPLACE. Each mode represents a distinct strategy for applying new scan data.</p>"},{"location":"concepts/import-modes/#ip-level-behavior-applies-to-all-modes","title":"IP-level behavior (applies to all modes)","text":"<ul> <li>Import modes never remove IPs.</li> <li>If an IP exists in the incoming report and is missing in ScanLedger, it is always added.</li> <li>This behavior is identical for INSERT, APPEND, UPDATE, REPLACE.</li> </ul>"},{"location":"concepts/import-modes/#port-level-import-semantics","title":"Port-level import semantics","text":"<p>This table explains how a single port is processed depending on the import mode. Only port-level logic is shown. IP logic is handled separately.</p> ScanLedger (before) Incoming report APPEND Result UPDATE Result REPLACE Result 22/tcp open OpenSSH 22/tcp open \u2014 \u26aa <code>22/tcp open OpenSSH</code> \u26aa <code>22/tcp open OpenSSH</code> \ud83d\udfe1 <code>22/tcp open \u2014</code> 22/tcp open \u2014 22/tcp open OpenSSH \u26aa <code>22/tcp open \u2014</code> \ud83d\udfe1 <code>22/tcp open OpenSSH</code> \ud83d\udfe1 <code>22/tcp open OpenSSH</code> 22/tcp open \u2014 22/tcp closed \u26aa <code>22/tcp open \u2014</code> \u26aa <code>22/tcp open \u2014</code> \ud83d\udd34 <code>22/tcp closed</code> empty 22/tcp open OpenSSH \ud83d\udfe2 <code>22/tcp open OpenSSH</code> \ud83d\udfe2 <code>22/tcp open OpenSSH</code> \ud83d\udfe2 <code>22/tcp open OpenSSH</code> 22/tcp open \u2014 empty \u26aa <code>22/tcp open \u2014</code> \u26aa <code>22/tcp open \u2014</code> \u26aa <code>22/tcp open \u2014</code>"},{"location":"concepts/import-modes/#legend","title":"Legend","text":"<ul> <li>\ud83d\udfe2 new \u2014 port was added\u00a0\u00a0</li> <li>\ud83d\udfe1 changed \u2014 existing port was updated\u00a0\u00a0</li> <li>\u26aa unchanged \u2014 existing port was not modified\u00a0\u00a0</li> <li>\ud83d\udd34 removed \u2014 port state changed to <code>closed</code> </li> <li><code>empty</code> \u2014 port does not exist in ScanLedger or incoming report</li> </ul>"},{"location":"concepts/import-modes/#how-to-read-this-short-but-critical","title":"How to read this (short, but critical)","text":""},{"location":"concepts/import-modes/#insert","title":"INSERT","text":"<ul> <li>operates on IPs only </li> <li>ports are ignored\u00a0\u00a0</li> <li>no port-level changes are applied\u00a0\u00a0</li> </ul>"},{"location":"concepts/import-modes/#append","title":"APPEND","text":"<ul> <li>adds port only if it does not exist\u00a0\u00a0</li> <li>never updates existing ports\u00a0\u00a0</li> <li>never closes a port\u00a0\u00a0</li> </ul>"},{"location":"concepts/import-modes/#update","title":"UPDATE","text":"<ul> <li>updates existing port if present in report\u00a0\u00a0</li> <li>adds new ports if missing\u00a0\u00a0</li> <li>ignores <code>closed</code> state on import\u00a0\u00a0</li> <li>never closes a port\u00a0\u00a0</li> </ul>"},{"location":"concepts/import-modes/#replace","title":"REPLACE","text":"<ul> <li>updates existing port if present in report\u00a0\u00a0</li> <li>adds new ports if missing\u00a0\u00a0</li> <li>applies <code>closed</code> state from the report\u00a0\u00a0</li> <li>never removes ports that are absent from the report</li> </ul>"},{"location":"concepts/import-modes/#when-to-use-each-import-mode","title":"When to use each import mode","text":""},{"location":"concepts/import-modes/#insert_1","title":"INSERT","text":"<p>Use when you need to merge multiple scans with overlapping hosts and only want to add IPs, without touching port data.</p> <p>Typical scenarios: - merging recon scans that partially overlap by hosts - importing repeated scans of the same scope - aggregating host lists from different sources</p>"},{"location":"concepts/import-modes/#append_1","title":"APPEND","text":"<p>Use when scan results may be incomplete and you want to add new ports without changing existing ones.</p> <p>Typical scenarios:</p> <ul> <li>fast or high-rate port scans</li> <li>distributed scans with possible packet loss</li> <li>scans where some open ports may be missed</li> </ul>"},{"location":"concepts/import-modes/#update_1","title":"UPDATE","text":"<p>Use when you want to update services and open ports, but do not want closed ports to affect existing data.</p> <p>Typical scenarios:</p> <ul> <li>service detection and version scanning</li> <li>follow-up scans after initial port discovery</li> <li>gradually improving service accuracy</li> </ul>"},{"location":"concepts/import-modes/#replace_1","title":"REPLACE","text":"<p>Use when scan results are reliable and should be applied as-is to the current state.</p> <p>Typical scenarios:</p> <ul> <li>low-rate, high-confidence scans</li> <li>internal network scans</li> <li>scheduled scans used to refresh port state</li> <li>safe for partial scans: ports missing from the report are not removed unless explicitly reported as closed</li> </ul>"},{"location":"concepts/import-modes/append/","title":"Append Mode","text":"<p>The Append mode adds new ports to existing IPs without modifying existing ones. It is useful when combining results from multiple scans or phases.</p>"},{"location":"concepts/import-modes/append/#behavior","title":"Behavior","text":"<ul> <li>If an IP does not exist in the project \u2192 it will be added with its ports.  </li> <li>If an IP exists \u2192 new ports are added, existing ports stay unchanged.  </li> <li>Existing fields (state, banner, service) are never updated or removed.  </li> </ul> <p>Image placeholder: canvas showing dataset with IP and ports \u2192 new ports added while existing remain unchanged.</p>"},{"location":"concepts/import-modes/append/#when-to-use","title":"When to Use","text":"<p>Use Append when you want to extend data without affecting existing results, for example:  </p> <ul> <li>Combining partial results from different port ranges.  </li> <li>Running parallel workers to cover large scopes faster.  </li> <li>Adding data from additional scan phases (e.g. UDP, slow services).</li> </ul>"},{"location":"concepts/import-modes/append/#example","title":"Example","text":"<pre><code>falcli project ips import --file report_append1.xml --mode append\n</code></pre>"},{"location":"concepts/import-modes/insert/","title":"Insert Mode","text":"<p>The Insert mode adds only new IP addresses to a project. Existing IPs and their ports are never modified.</p>"},{"location":"concepts/import-modes/insert/#behavior","title":"Behavior","text":"<ul> <li>If an IP does not exist in the project \u2192 it will be added with its ports.  </li> <li>If an IP already exists \u2192 it is skipped completely.  </li> <li>Ports are only added for new IPs; existing IPs and their ports remain untouched.  </li> </ul> <p>Image placeholder: canvas showing input list with duplicates \u2192 only new IPs added to the dataset.</p>"},{"location":"concepts/import-modes/insert/#when-to-use","title":"When to Use","text":"<p>Use Insert when you want to import results without touching existing data, for example:  </p> <ul> <li>Importing results from segmented or partial scans.  </li> <li>Loading results from offline sources or external tools.  </li> <li>Combining data from multiple discovery steps without risk of overwriting.  </li> </ul>"},{"location":"concepts/import-modes/insert/#example","title":"Example","text":"<pre><code>falcli project ips import --file report_insert1.xml --mode insert\n</code></pre> <p>Output:</p> <pre><code>Imported IPs report into project 'example-project-id'. Result: 2 IPs.\n</code></pre> <p>If you run it again with the same file, duplicates are skipped:</p> <pre><code>No new IPs added in project\n</code></pre>"},{"location":"concepts/import-modes/insert/#reference","title":"Reference","text":"<ul> <li>Practical Example on GitHub</li> </ul>"},{"location":"concepts/import-modes/replace/","title":"Replace Mode","text":"<p>The Replace mode imports new results and overwrites existing ports for matching IPs. Ports not included in the new scan remain unchanged.</p>"},{"location":"concepts/import-modes/replace/#behavior","title":"Behavior","text":"<ul> <li>If an IP does not exist in the project \u2192 it will be added with its ports.  </li> <li>If an IP exists \u2192 ports from the new report replace existing ones for that IP.  </li> <li>Ports not present in the new report are removed only if they were explicitly included and marked as closed.  </li> </ul> <p>Image placeholder: canvas showing dataset before and after \u2192 updated ports overwrite old ones.</p>"},{"location":"concepts/import-modes/replace/#when-to-use","title":"When to Use","text":"<p>Use Replace when you want to refresh data for specific IPs and overwrite outdated port states, for example:  </p> <ul> <li>Rescanning an IP with a different port range.  </li> <li>Correcting results after a failed or partial scan.  </li> <li>Ensuring only the latest scan data is kept for those IPs.  </li> </ul>"},{"location":"concepts/import-modes/replace/#example","title":"Example","text":"<pre><code>falcli project ips import --file report_replace1.xml --mode replace\n</code></pre>"},{"location":"concepts/import-modes/replace/#reference","title":"Reference","text":"<ul> <li>Practical Example on GitHub</li> </ul>"},{"location":"concepts/import-modes/update/","title":"Update Mode","text":"<p>The Update mode adds new IPs and ports, and updates existing ones when their state, banner, or service changes. Existing data is never removed.</p>"},{"location":"concepts/import-modes/update/#behavior","title":"Behavior","text":"<ul> <li>If an IP does not exist in the project \u2192 it will be added with its ports.  </li> <li>If an IP exists \u2192  </li> <li>new ports are added,  </li> <li>existing ports are updated if state, banner, or service differs,  </li> <li>no ports are deleted.  </li> </ul> <p>Image placeholder: canvas showing dataset before and after \u2192 existing ports keep their place, only fields updated.</p>"},{"location":"concepts/import-modes/update/#when-to-use","title":"When to Use","text":"<p>Use Update when you want to refine or enrich results without losing data, for example:  </p> <ul> <li>Adding results from a scan with version or banner detection.  </li> <li>Combining results from different tools for the same targets.  </li> <li>Keeping track of changes while preserving all existing data.  </li> </ul>"},{"location":"concepts/import-modes/update/#example","title":"Example","text":"<pre><code>falcli project ips import --file report_update1.xml --mode update\n</code></pre>"},{"location":"installation/","title":"Installation","text":"<p>Falcoria is open source, but the complete service is not intended to be installed locally as a whole. Each component is maintained in its own repository, and installation instructions are provided there.</p> <p>For full installation guides, see the GitHub repositories of the respective components.</p> <ul> <li>CLI (falcli)</li> <li>ScanLedger</li> <li>Tasker</li> <li>Worker</li> </ul>"},{"location":"installation/falcli/","title":"falcli","text":"<p>falcli is the CLI client used to interact with ScanLedger and manage scans in Falcoria. It provides command-line tools for launching scans, retrieving results, and managing scan configurations.</p> <p>GitHub repository</p> <p>For installation and usage instructions, see the GitHub repository.</p>"},{"location":"installation/scanledger/","title":"scanledger","text":"<p>Scanledger is the central storage for scan results and deduplication logic in Falcoria. It manages the database of discovered hosts, ports, and services, and ensures data consistency across scans.</p> <p>GitHub repository</p> <p>For installation and usage instructions, see the GitHub repository.</p>"},{"location":"installation/tasker/","title":"tasker","text":"<p>Tasker orchestrates and distributes scan tasks to workers in the Falcoria system. It acts as the central coordinator, ensuring that scan jobs are assigned efficiently and results are collected from multiple sources.</p> <p>GitHub repository</p> <p>For installation and usage instructions, see the GitHub repository.</p>"},{"location":"installation/worker/","title":"worker","text":"<p>Worker executes scanning tasks assigned by Tasker and sends results back to ScanLedger. It is responsible for performing the actual port scans and service detection as part of the distributed scanning workflow.</p> <p>GitHub repository</p> <p>For installation and usage instructions, see the GitHub repository.</p>"},{"location":"others/typical-workflow/","title":"Typical Workflow","text":"<p>This section demonstrates a step-by-step workflow in Falcoria, from creating a project to exporting results. Each phase includes example commands using <code>falcli</code>. Illustrations are included to show how data flows into the project canvas.</p>"},{"location":"others/typical-workflow/#create-a-project","title":"Create a project","text":"<p>Before running scans, a project must be created. The project acts as a single dataset (\"canvas\") where results accumulate and where the team collaborates.</p> <pre><code>falcli project create test_project\n</code></pre> <p></p>"},{"location":"others/typical-workflow/#1-initial-scan-http-ports-only","title":"1. Initial scan (HTTP ports only)","text":"<p>Upload the initial list of targets and run a scan limited to HTTP ports.</p> <pre><code>falcli scan start --config http-only.yaml --targets-file hosts.txt\n</code></pre> <p></p>"},{"location":"others/typical-workflow/#2-adding-new-targets","title":"2. Adding new targets","text":"<p>If the target file is updated with additional hosts, Falcoria will skip already scanned or queued targets and process only the new ones.</p> <pre><code>falcli scan start --config http-only.yaml --targets-file hosts.txt\n</code></pre> <p></p>"},{"location":"others/typical-workflow/#3-full-port-scan-append","title":"3. Full port scan (Append)","text":"<p>Expand the scan to the full port range. The Append mode extends the project canvas: existing results stay untouched, new scan data is appended alongside them.</p> <pre><code>falcli scan start --config full-range.yaml --mode append --targets-file hosts.txt\n</code></pre> <p></p> <p>\u2192 See Scan Management for details on checking status, stopping, or resuming scans.</p>"},{"location":"others/typical-workflow/#4-rescan-with-replace","title":"4. Rescan with Replace","text":"<p>Run a rescan on a specific range of ports (e.g., top-1000). The Replace mode refreshes a chosen part of the canvas: ports in the selected range are updated, with changes highlighted and stored in history.</p> <pre><code>falcli scan start --config top-1000.yaml --mode replace --targets-file hosts.txt\n</code></pre> <p></p>"},{"location":"others/typical-workflow/#5-report-download","title":"5. Report download","text":"<p>At any time, results can be exported from the project.</p> <pre><code>falcli project ips download\n</code></pre>"},{"location":"workflow/","title":"Workflow","text":"<p>Falcoria workflows show how scanning, data management, and collaboration happen in practice. This section provides step-by-step guides and real-world examples to help you understand and use Falcoria effectively.</p> <p>You\u2019ll find:</p> <ul> <li>Typical scanning workflows for teams and individuals</li> <li>How to import external reports and merge data</li> <li>Best practices for managing projects and results</li> </ul> <p>Explore the topics below to get started with Falcoria workflows.</p>"},{"location":"workflow/import-reports/","title":"Import Reports","text":"<p>Falcoria allows importing scan results directly into the system. This is useful when you want to reuse data from external tools or work in offline projects.</p>"},{"location":"workflow/import-reports/#how-it-works","title":"How It Works","text":"<ul> <li>Reports can be imported using different Import Modes.  </li> <li>Importing does not require the built-in scanner \u2014 you can load results manually.  </li> <li>This makes it possible to use Falcoria as a shared storage and single source of truth for the team.  </li> </ul>"},{"location":"workflow/import-reports/#when-to-use","title":"When To Use","text":"<ul> <li>Partial scans: if you scan part of the scope separately and want to merge the results.  </li> <li>Offline projects: when you don\u2019t run scans through Falcoria but need a central database for results.  </li> <li>External tools: when results are produced outside and should be consolidated in one place.</li> </ul>"},{"location":"workflow/typical-workflow/","title":"Typical Workflow","text":"<p>This section demonstrates a step-by-step workflow in Falcoria, from creating a project to exporting results. Each phase includes example commands using <code>falcli</code>. Illustrations are included to show how data flows into the project canvas.</p>"},{"location":"workflow/typical-workflow/#create-a-project","title":"Create a project","text":"<p>Before running scans, a project must be created. The project acts as a persistent dataset that is updated over time by scans.</p> <pre><code>falcli project create test_project\n</code></pre>"},{"location":"workflow/typical-workflow/#1-initial-scan-http-ports-only","title":"1. Initial scan (HTTP ports only)","text":"<p>Upload the initial list of targets and run a scan limited to HTTP ports.</p> <pre><code>falcli scan start --config http-only.yaml --targets-file hosts.txt\n</code></pre>"},{"location":"workflow/typical-workflow/#2-adding-new-targets","title":"2. Adding new targets","text":"<p>If the target file is updated with additional hosts, Falcoria detects the difference:</p> <ul> <li>Already scanned or queued targets are skipped</li> <li>Only new entries are processed</li> </ul> <pre><code># Example: file was updated from 2 to 3 entries\n# old: host1, host2\n# new: host1, host2, host3\n# only host3 will be sent to scan\n\nfalcli scan start --config http-only.yaml --targets-file hosts.txt\n</code></pre>"},{"location":"workflow/typical-workflow/#3-full-port-scan-append","title":"3. Full port scan (Append)","text":"<p>Expand the scan to the full port range. The Append mode extends the project dataset:</p> <ul> <li>Existing results remain untouched</li> <li>New scan data is added next to them</li> <li>Data from previously covered ports is not overwritten</li> </ul> <pre><code>falcli scan start --config full-range.yaml --mode append --targets-file hosts.txt\n</code></pre>"},{"location":"workflow/typical-workflow/#4-rescan-with-replace","title":"4. Rescan with Replace","text":"<p>Run a rescan on a specific range of ports (e.g., top-1000). The Replace mode updates only the selected range:</p> <ul> <li>Ports in scope are refreshed</li> <li>All other results stay unchanged</li> <li>Changes are highlighted and stored in history</li> </ul> <pre><code>falcli scan start --config top-1000.yaml --mode replace --targets-file hosts.txt\n</code></pre> <p>To get history of changes:</p> <pre><code>falcli project ips history\n</code></pre>"},{"location":"workflow/typical-workflow/#5-report-download","title":"5. Report download","text":"<p>At any time, results can be exported from the project. Even after multiple updates, the dataset is always consistent.</p> <pre><code>falcli project ips download\n</code></pre> <p>Key takeaway: In Falcoria, data from previous scans stays intact. Only the chosen targets or port ranges are updated, while the project is always available as a single, unified report.</p>"}]}